<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#4142e0">
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="/favicon.ico">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>TrackDrop</title>
    <!-- Google Fonts: JetBrains Mono for that clean techy feel -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #4142e0;
            --secondary-color: #3fbbda;
            --accent-color: #80f2ff;
            --background-color: #0d0d1a;
            --card-background: #1a1a2e;
            --text-color: #e8e8f0;
            --text-muted: #8888a0;
            --border-color: #2a2a4a;
            --success-color: #00d68f;
            --error-color: #ff4757;
            --info-color: #3fbbda;
            --warning-color: #ffb400;
            --font-mono: 'JetBrains Mono', monospace;
            --font-sans: 'Outfit', -apple-system, sans-serif;
            --glow-primary: rgba(65, 66, 224, 0.4);
            --glow-accent: rgba(128, 242, 255, 0.3);
        }

        body {
            font-family: var(--font-sans);
            margin: 0;
            padding: 20px;
            background-color: var(--background-color);
            background-image:
                radial-gradient(ellipse at 20% 0%, rgba(65, 66, 224, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 100%, rgba(63, 187, 218, 0.06) 0%, transparent 50%);
            color: var(--text-color);
            line-height: 1.6;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            box-sizing: border-box;
            transition: padding-right 0.3s cubic-bezier(0.4, 0, 0.2, 1), justify-content 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body.download-queue-panel-open {
            padding-right: calc( (500px) + 20px);
            justify-content: flex-start; /* Align main content to the left when panel is open */
        }
        #downloadQueueModalContent {
            padding-right: 40px;
        }

        .container {
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            background-color: var(--card-background);
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.03);
            animation: containerFadeIn 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            transition: max-width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
        }

        @keyframes containerFadeIn {
            from { opacity: 0; transform: translateY(20px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        /* When panel is open, container will naturally adjust within the new body padding. */
        /* No specific .container adjustment needed when body.download-queue-panel-open is active. */

        .header-icons {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 15px; /* Space between icons */
        }

        .header-icon {
            width: 26px; 
            height: 26px;
            cursor: pointer;
            filter: invert(1);
            opacity: 0.7;
            transition: all 0.3s ease;
        }

        .header-icon:hover {
            filter: invert(1);
            opacity: 1;
        }

        /* Styles for the download queue modal */
        .header-icon-top-left {
            position: absolute;
            top: 20px;
            left: 20px;
        }
        .header-icons-top-right {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 15px; /* Space between icons */
        }
        .download-queue-modal {
            position: fixed;
            top: 12px;
            right: calc(-480px);
            width: 480px;
            max-width: calc(95vw - 24px);
            height: calc(100% - 24px);
            background: var(--card-background);
            backdrop-filter: blur(20px);
            box-shadow: -20px 0 60px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.05);
            z-index: 1000;
            transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            border-radius: 16px 0 0 16px;
        }

        .download-queue-modal.open {
            right: 0;
        }

        .download-queue-modal .modal-content {
            /* Override general .modal-content styles */
            margin: 0;
            width: 100%;
            max-width: none;
            max-height: none;
            border-radius: 0;
            background: transparent;
            box-shadow: none;
            animation: none;
            /* Actual layout */
            padding: 24px;
            box-sizing: border-box;
            flex: 1 1 0;
            min-height: 0;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            overflow: hidden;
        }

        .dq-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        }

        .dq-header h2 {
            font-family: var(--font-mono);
            font-size: 0.9em;
            font-weight: 600;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: var(--text-muted);
            margin: 0;
        }

        .dq-header-badge {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            font-family: var(--font-mono);
            font-size: 0.7em;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 20px;
            letter-spacing: 0.05em;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .download-queue-item {
            display: flex;
            flex-direction: column;
            padding: 16px;
            margin-bottom: 12px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.04);
            transition: background 0.2s ease, border-color 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .download-queue-item.dq-animate-in {
            animation: dqItemSlideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1) backwards;
        }

        @keyframes dqItemSlideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .download-queue-item:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.08);
        }

        .download-queue-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            border-radius: 3px 0 0 3px;
            transition: all 0.3s ease;
        }

        .download-queue-item.in_progress::before {
            background: linear-gradient(180deg, var(--info-color), var(--primary-color));
            box-shadow: 0 0 12px var(--glow-accent);
        }
        .download-queue-item.completed::before {
            background: var(--success-color);
            box-shadow: 0 0 8px rgba(0, 214, 143, 0.4);
        }
        .download-queue-item.failed::before {
            background: var(--error-color);
            box-shadow: 0 0 8px rgba(255, 71, 87, 0.4);
        }

        .download-queue-item-header {
            display: flex;
            align-items: flex-start;
            width: 100%;
            gap: 12px;
        }

        .download-queue-item .track-info {
            flex-grow: 1;
            min-width: 0;
        }

        .download-queue-item .track-info .track-title {
            font-family: var(--font-sans);
            font-weight: 600;
            font-size: 0.95em;
            color: var(--text-color);
            margin: 0;
            line-height: 1.3;
        }

        .download-queue-item .track-info > div {
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
        }

        .download-queue-item .status-icon {
            width: 36px;
            height: 36px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.05);
        }

        .download-queue-item .status-icon.in_progress {
            background: rgba(63, 187, 218, 0.15);
            animation: statusPulse 2s ease-in-out infinite;
        }

        @keyframes statusPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }

        @keyframes badgePulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(65, 66, 224, 0.4); }
            50% { transform: scale(1.1); box-shadow: 0 0 8px 2px rgba(65, 66, 224, 0.6); }
        }

        .download-queue-item .status-icon.completed {
            background: rgba(0, 214, 143, 0.15);
        }
        .download-queue-item .status-icon.completed svg { color: var(--success-color); }
        .download-queue-item .status-icon.failed {
            background: rgba(255, 71, 87, 0.15);
        }
        .download-queue-item .status-icon.failed svg { color: var(--error-color); }

        /* Enhanced Progress bar */
        .dq-progress-bar {
            width: 100%;
            height: 6px;
            background-color: rgba(255, 255, 255, 0.06);
            border-radius: 3px;
            margin-top: 12px;
            overflow: hidden;
            position: relative;
        }

        .dq-progress-bar-inner {
            height: 100%;
            border-radius: 3px;
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .dq-progress-bar-inner::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.3) 50%, transparent 100%);
            animation: progressShimmer 1.5s ease-in-out infinite;
        }

        @keyframes progressShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Stats row */
        .dq-stats {
            display: flex;
            gap: 16px;
            font-family: var(--font-mono);
            font-size: 0.75em;
            margin-top: 10px;
            flex-wrap: wrap;
            color: var(--text-muted);
        }

        .dq-stat {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .dq-stat-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            display: inline-block;
        }

        .dq-stat-dot.downloaded { background-color: var(--success-color); box-shadow: 0 0 6px rgba(0, 214, 143, 0.5); }
        .dq-stat-dot.skipped { background-color: var(--secondary-color); box-shadow: 0 0 6px rgba(63, 187, 218, 0.5); }
        .dq-stat-dot.failed { background-color: var(--error-color); box-shadow: 0 0 6px rgba(255, 71, 87, 0.5); }
        .dq-stat-dot.pending { background-color: #555; }

        /* Expandable track list */
        .dq-expand-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 0.7em;
            padding: 6px 0;
            margin-top: 8px;
            transition: color 0.2s;
            width: auto;
            box-shadow: none;
            letter-spacing: 0.03em;
        }

        .dq-expand-btn:hover {
            color: var(--accent-color);
            background: none;
            transform: none;
        }

        .dq-track-list {
            width: 100%;
            max-height: 250px;
            overflow-y: auto;
            margin-top: 8px;
            display: none;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 8px;
        }

        .dq-track-list::-webkit-scrollbar {
            width: 4px;
        }

        .dq-track-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .dq-track-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        .dq-track-list.open { display: block; }

        .dq-track-entry {
            display: flex;
            align-items: center;
            padding: 6px 10px;
            font-family: var(--font-sans);
            font-size: 0.8em;
            border-radius: 6px;
            gap: 10px;
            transition: background 0.2s;
        }

        .dq-track-entry:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .dq-track-entry .dq-track-status-icon {
            width: 14px;
            height: 14px;
            flex-shrink: 0;
        }

        .dq-track-entry .dq-track-label {
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            color: var(--text-color);
        }

        .dq-track-entry .dq-track-msg {
            color: var(--text-muted);
            font-size: 0.85em;
            flex-shrink: 0;
            font-family: var(--font-mono);
        }

        /* Source stats styling */
        .dq-source-stats {
            display: flex;
            gap: 12px;
            font-family: var(--font-mono);
            font-size: 0.7em;
            margin-top: 8px;
            flex-wrap: wrap;
            color: var(--text-muted);
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.15);
            border-radius: 6px;
        }

        /* Empty state */
        .dq-empty {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-muted);
        }

        .dq-empty-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            opacity: 0.3;
        }

        .dq-empty p {
            font-family: var(--font-mono);
            font-size: 0.85em;
            letter-spacing: 0.03em;
        }

        /* Responsive adjustments for the download queue */
        /* Responsive adjustments for the download queue */
        @media (max-width: 768px) {
            .download-queue-modal {
                width: 100%;
                max-width: none;
                right: -100%;
                top: 0;
                height: 100%;
                border-radius: 0;
                z-index: 1100;
            }
            body.download-queue-panel-open {
                padding-right: 20px;
            }
            .dq-header h2 {
                font-size: 0.8em;
            }
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            animation: modalFadeIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: linear-gradient(180deg, var(--card-background) 0%, rgba(20, 20, 36, 0.98) 100%);
            margin: 8% auto;
            padding: 28px;
            border-radius: 16px;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.05);
            width: 90%;
            max-width: 520px;
            position: relative;
            max-height: 80vh;
            overflow-y: auto;
            animation: modalContentSlide 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes modalContentSlide {
            from { opacity: 0; transform: translateY(-20px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .modal-content::-webkit-scrollbar {
            width: 6px;
        }

        .modal-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .modal-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .close {
            position: absolute;
            top: 16px;
            right: 20px;
            color: var(--text-muted);
            font-size: 24px;
            font-weight: 400;
            cursor: pointer;
            opacity: 0.6;
            transition: all 0.2s ease;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
        }

        .close:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.05);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1 {
            font-family: var(--font-sans);
            color: var(--text-color);
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.2em;
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        h2 {
            font-family: var(--font-sans);
            color: var(--text-color);
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.5em;
            font-weight: 600;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-family: var(--font-sans);
            font-weight: 500;
            font-size: 0.9em;
            color: var(--text-color);
        }

        input[type="text"], input[type="password"] {
            width: calc(100% - 28px);
            padding: 14px;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            font-family: var(--font-sans);
            font-size: 0.95em;
            background-color: rgba(255, 255, 255, 0.04);
            color: var(--text-color);
            transition: all 0.2s ease;
        }

        input[type="text"]::placeholder, input[type="password"]::placeholder {
            color: var(--text-muted);
            opacity: 0.6;
        }

        input[type="text"]:focus, input[type="password"]:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(65, 66, 224, 0.15);
            background-color: rgba(255, 255, 255, 0.06);
            outline: none;
        }

        button {
            background: linear-gradient(135deg, var(--primary-color) 0%, #5253f0 100%);
            color: white;
            padding: 12px 22px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-family: var(--font-sans);
            font-size: 0.9em;
            font-weight: 600;
            margin-right: 10px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(65, 66, 224, 0.25);
        }

        button:hover {
            background: linear-gradient(135deg, #5253f0 0%, var(--secondary-color) 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(65, 66, 224, 0.35);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(65, 66, 224, 0.2);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Message notifications */
        .message {
            position: fixed;
            bottom: 24px;
            right: 24px;
            padding: 16px 20px;
            border-radius: 12px;
            font-family: var(--font-sans);
            font-weight: 500;
            font-size: 0.9em;
            animation: messageSlideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            max-width: 380px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        @keyframes messageSlideIn {
            from { opacity: 0; transform: translateY(20px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .message.success {
            background: rgba(0, 214, 143, 0.15);
            color: var(--success-color);
            border-color: rgba(0, 214, 143, 0.3);
        }
        .message.error {
            background: rgba(255, 71, 87, 0.15);
            color: var(--error-color);
            border-color: rgba(255, 71, 87, 0.3);
        }
        .message.info {
            background: rgba(63, 187, 218, 0.15);
            color: var(--info-color);
            border-color: rgba(63, 187, 218, 0.3);
        }
        .message.warning {
            background-color: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border: 1px solid #ffc107;
        }

        .playlist-section {
            margin-top: 40px;
            border-top: 1px solid var(--border-color);
            padding-top: 30px;
        }

        .playlist-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .playlist-toggle {
            background: none;
            border: none;
            color: var(--accent-color);
            cursor: pointer;
            font-size: 1.2em;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }

        .playlist-toggle:hover {
            background-color: rgba(255, 193, 7, 0.1);
        }

        .playlist-content {
            display: block;
        }

        .playlist-content.collapsed {
            display: none;
        }

        .playlist-status {
            font-size: 0.9em;
            color: var(--text-color);
            margin-left: 10px;
        }

        .playlist-item {
            display: flex;
            align-items: center;
            background-color: var(--card-background);
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .playlist-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .feedback-buttons {
            display: flex;
            flex-direction: row;
            gap: 5px;
            margin-left: 15px;
        }

        .feedback-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s ease, transform 0.1s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
        }

        .feedback-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
            transform: scale(1.1);
        }

        .feedback-btn:active {
            transform: scale(0.95);
        }

        .like-btn:hover {
            background-color: rgba(40, 167, 69, 0.2);
        }

        .dislike-btn:hover {
            background-color: rgba(220, 53, 69, 0.2);
        }

        .feedback-icon {
            width: 20px;
            height: 20px;
            transition: opacity 0.2s ease;
        }

        .feedback-btn:hover .feedback-icon {
            opacity: 1;
        }

        .feedback-icon.success-feedback {
            background-color: var(--success-color);
            transform: scale(1.2);
        }

        .feedback-icon.error-feedback {
            background-color: var(--error-color);
            transform: scale(1.2);
        }

        .album-art-container {
            position: relative;
            width: 60px;
            height: 60px;
            min-width: 60px;
            margin-right: 20px;
            border-radius: 6px;
            background-color: #3a3a5a;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .album-art {
            width: 100%;
            height: 100%;
            border-radius: 6px;
            object-fit: cover;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .album-art.loaded {
            opacity: 1;
        }

        .album-art-spinner {
            position: absolute;
            display: block;
            width: 32px; /* Adjusted size */
            height: 32px; /* Adjusted size */
            background-image: url('/assets/default-album.svg');
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
            animation: spin 2s linear infinite; /* Use spin animation */
        }

        .track-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .track-title {
            font-weight: 700;
            margin: 0;
            font-size: 1.1em;
            color: var(--text-color);
        }

        .track-artist {
            margin: 4px 0 2px 0;
            color: #b0b0b0;
            font-size: 0.95em;
        }

        .track-album {
            margin: 2px 0 0 0;
            font-style: italic;
            color: #888;
            font-size: 0.9em;
        }

        .logo {
            width: 100%;
            height: auto;
            max-width: 125px;
            display: block;
            margin: 0 auto 20px auto;
            filter: drop-shadow(0 0 5px rgba(0,0,0,0.3));
        }

        .service-logo {
            margin: 0 20px 20px 0;
            max-width: 250px;
        }

        .settings {
            background-color: #3a3a5a;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            margin-bottom: 30px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .settings summary {
            cursor: pointer;
            font-weight: bold;
            color: var(--accent-color);
            font-size: 1.2em;
            padding: 5px 0;
            transition: color 0.3s ease;
        }

        .settings summary:hover {
            color: var(--primary-color);
        }

        .playlist-controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .spinner {
            display: inline-block;
            width: 32px; /* Twice as big */
            height: 32px; /* Twice as big */
            background-image: url('/assets/default-album.svg');
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
            animation: spin 2s linear infinite; /* Apply spin animation */
        }

        /* Specific style for spinner within download queue modal */
        .download-queue-modal .spinner {
            width: 48px; /* Twice as big */
            height: 48px; /* Twice as big */
        }

        /* Collapse handle on left edge */
        .dq-collapse-handle {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 60px;
            background: rgba(255, 255, 255, 0.06);
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 1001;
        }

        .dq-collapse-handle:hover {
            background: rgba(255, 255, 255, 0.12);
            width: 28px;
        }

        .dq-collapse-handle svg {
            width: 16px;
            height: 16px;
            color: var(--text-muted);
            transition: transform 0.3s ease;
        }

        .dq-collapse-handle:hover svg {
            color: var(--text-color);
        }

        @keyframes pulse {
            0% { transform: scale(0.8); opacity: 0.6; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0.6; }
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .download-btn {
            background-color: var(--accent-color) !important;
            color: black !important;
        }

        .download-btn:hover {
            background-color: #8080ff !important;
        }

        /* Fresh Releases Carousel */
        .carousel-container {
            display: flex;
            align-items: center;
            position: relative;
            overflow: hidden;
        }

        .carousel {
            display: flex;
            overflow-x: auto;
            scroll-behavior: smooth;
            scrollbar-width: none;
            -ms-overflow-style: none;
            gap: 20px;
            padding: 10px 0;
        }

        .carousel::-webkit-scrollbar {
            display: none;
        }

        .carousel-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        .carousel-btn:hover {
            background-color: var(--secondary-color);
            transform: scale(1.1);
        }

        .prev-btn {
            margin-right: 10px;
        }

        .next-btn {
            margin-left: 10px;
        }

        .release-item {
            flex: 0 0 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--card-background);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-align: center;
            min-height: 280px;
        }

        .release-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .release-art-container {
            position: relative;
            width: 120px;
            height: 120px;
            border-radius: 8px;
            background-color: #3a3a5a;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            margin-bottom: 10px;
        }

        .release-art {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            object-fit: cover;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .release-art.loaded {
            opacity: 1;
        }

        .release-art-spinner {
            position: absolute;
            display: block;
            width: 40px; /* Adjusted size */
            height: 40px; /* Adjusted size */
            background-image: url('/assets/default-album.svg');
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
            animation: spin 2s linear infinite; /* Use spin animation */
        }

        .release-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            justify-content: space-between;
            height: 100%;
        }

        .release-artist {
            font-weight: bold;
            font-size: 1em;
            color: var(--text-color);
            margin: 0;
        }

        .release-album {
            font-weight: normal;
            font-size: 0.9em;
            color: var(--text-color);
            margin: 0;
        }

        .release-date {
            font-size: 0.8em;
            color: #b0b0b0;
            margin: 0;
        }

        .release-download-btn {
            background-color: var(--accent-color);
            color: black;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 0.8em;
            cursor: pointer;
            margin-top: 5px;
            transition: background-color 0.3s ease;
        }

        .release-download-btn:hover {
            background-color: #8080ff;
        }

        .release-download-btn:disabled {
            background-color: var(--border-color);
            color: var(--text-color);
            cursor: not-allowed;
        }

        .download-link-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            h1 {
                font-size: 2em;
            }
            .playlist-item {
                flex-direction: column;
                align-items: flex-start;
            }
            .album-art {
                margin-bottom: 10px;
                margin-right: 0;
            }
            .playlist-controls {
                flex-direction: column;
            }
            button {
                width: 100%;
                margin-right: 0;
                margin-bottom: 10px;
            }
            .release-item {
                flex: 0 0 150px;
            }
            .release-art {
                width: 100px;
                height: 100px;
            }
            .download-link-row {
                flex-direction: column;
            }
            .download-link-row input[type="text"] {
                width: 100% !important;
            }
            .download-link-row button {
                width: 100%;
            }
        }
        /* Playlist mode popup */
        .pl-popup-overlay {
            display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.6); z-index: 2000; align-items: center; justify-content: center;
        }
        .pl-popup-overlay.open { display: flex; }
        .pl-popup {
            background: #2a2a3e; border-radius: 12px; padding: 24px; max-width: 420px; width: 90%;
            box-shadow: 0 8px 32px rgba(0,0,0,0.7); border: 1px solid rgba(255,255,255,0.1);
        }
        .pl-popup h3 { margin: 0 0 12px; }
        .pl-popup p { color: #b0b0b0; font-size: 0.9em; margin: 0 0 16px; }
        .pl-popup button.btn-once {
            padding: 12px 16px; border: none; border-radius: 8px; cursor: pointer;
            font-size: 0.95em; transition: background 0.2s, opacity 0.2s;
            background: var(--accent-color); color: #000; font-weight: 500;
        }
        .pl-popup button.btn-once:hover:not(:disabled) { filter: brightness(1.15); }
        .pl-popup button.btn-once:disabled {
            background: #3a3a5a; color: #888; cursor: not-allowed; opacity: 0.7;
        }
        .pl-popup-interval {
            display: none; margin-top: 12px; padding: 12px; background: rgba(255,255,255,0.04);
            border-radius: 8px;
        }
        .pl-popup-interval.open { display: block; }
        .pl-popup-interval label { font-size: 0.85em; color: #b0b0b0; }
        .pl-popup-interval select {
            margin-top: 4px; padding: 8px; border-radius: 4px; width: 100%;
            background-color: #3a3a5a; color: var(--text-color); border: 1px solid var(--border-color);
        }

        /* Monitored playlists list in settings */
        .mp-list { margin-top: 12px; }
        .mp-item {
            display: flex; align-items: center; justify-content: space-between;
            padding: 10px 12px; border-radius: 8px; margin-bottom: 8px;
            background: rgba(255,255,255,0.04);
        }
        .mp-item-info { flex: 1; min-width: 0; }
        .mp-item-name { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .mp-item-meta { font-size: 0.8em; color: #888; margin-top: 2px; }
        .mp-item-actions { display: flex; gap: 6px; align-items: center; flex-shrink: 0; margin-left: 10px; }
        .mp-item-actions select {
            padding: 4px 6px; border-radius: 4px; font-size: 0.8em;
            background-color: #3a3a5a; color: var(--text-color); border: 1px solid var(--border-color);
        }
        .mp-item-actions button {
            padding: 4px 10px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8em;
        }
        .mp-btn-sync { background: var(--accent-color); color: #fff; }
        .mp-btn-remove { background: var(--error-color); color: #fff; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-icon-top-left">
            <!-- Gear icon inline for consistent styling -->
            <svg class="header-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" onclick="openSettingsModal()">
                <path d="M15 12C15 13.6569 13.6569 15 12 15C10.3431 15 9 13.6569 9 12C9 10.3431 10.3431 9 12 9C13.6569 9 15 10.3431 15 12Z" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M12.9046 3.06005C12.6988 3 12.4659 3 12 3C11.5341 3 11.3012 3 11.0954 3.06005C10.7942 3.14794 10.5281 3.32808 10.3346 3.57511C10.2024 3.74388 10.1159 3.96016 9.94291 4.39272C9.69419 5.01452 9.00393 5.33471 8.36857 5.123L7.79779 4.93281C7.3929 4.79785 7.19045 4.73036 6.99196 4.7188C6.70039 4.70181 6.4102 4.77032 6.15701 4.9159C5.98465 5.01501 5.83376 5.16591 5.53197 5.4677C5.21122 5.78845 5.05084 5.94882 4.94896 6.13189C4.79927 6.40084 4.73595 6.70934 4.76759 7.01551C4.78912 7.2239 4.87335 7.43449 5.04182 7.85566C5.30565 8.51523 5.05184 9.26878 4.44272 9.63433L4.16521 9.80087C3.74031 10.0558 3.52786 10.1833 3.37354 10.3588C3.23698 10.5141 3.13401 10.696 3.07109 10.893C3 11.1156 3 11.3658 3 11.8663C3 12.4589 3 12.7551 3.09462 13.0088C3.17823 13.2329 3.31422 13.4337 3.49124 13.5946C3.69158 13.7766 3.96395 13.8856 4.50866 14.1035C5.06534 14.3261 5.35196 14.9441 5.16236 15.5129L4.94721 16.1584C4.79819 16.6054 4.72367 16.829 4.7169 17.0486C4.70875 17.3127 4.77049 17.5742 4.89587 17.8067C5.00015 18.0002 5.16678 18.1668 5.5 18.5C5.83323 18.8332 5.99985 18.9998 6.19325 19.1041C6.4258 19.2295 6.68733 19.2913 6.9514 19.2831C7.17102 19.2763 7.39456 19.2018 7.84164 19.0528L8.36862 18.8771C9.00393 18.6654 9.69420 18.9855 9.94291 19.6073C10.1159 20.0398 10.2024 20.2561 10.3346 20.4249C10.5281 20.6719 10.7942 20.8521 11.0954 20.94C11.3012 21 11.5341 21 12 21C12.4659 21 12.6988 21 12.9046 20.94C13.2058 20.8521 13.4719 20.6719 13.6654 20.4249C13.7976 20.2561 13.8841 20.0398 14.0571 19.6073C14.3058 18.9855 14.9961 18.6654 15.6313 18.8773L16.1579 19.0529C16.605 19.2019 16.8286 19.2764 17.0482 19.2832C17.3123 19.2913 17.5738 19.2296 17.8063 19.1042C17.9997 18.9999 18.1664 18.8333 18.4996 18.5001C18.8328 18.1669 18.9994 18.0002 19.1037 17.8068C19.2291 17.5743 19.2908 17.3127 19.2827 17.0487C19.2759 16.8291 19.2014 16.6055 19.0524 16.1584L18.8374 15.5134C18.6477 14.9444 18.9344 14.3262 19.4913 14.1035C20.036 13.8856 20.3084 13.7766 20.5088 13.5946C20.6858 13.4337 20.8218 13.2329 20.9054 13.0088C21 12.7551 21 12.4589 21 11.8663C21 11.3658 21 11.1156 20.9289 10.893C20.866 10.696 20.763 10.5141 20.6265 10.3588C20.4721 10.1833 20.2597 10.0558 19.8348 9.80087L19.5569 9.63416C18.9478 9.26867 18.6939 8.51514 18.9578 7.85558C19.1262 7.43443 19.2105 7.22383 19.232 7.01543C19.2636 6.70926 19.2003 6.40077 19.0506 6.13181C18.9487 5.94875 18.7884 5.78837 18.4676 5.46762C18.1658 5.16584 18.0149 5.01494 17.8426 4.91583C17.5894 4.77024 17.2992 4.70174 17.0076 4.71872C16.8091 4.73029 16.6067 4.79777 16.2018 4.93273L15.6314 5.12287C14.9961 5.33464 14.3058 5.01450 14.0571 4.39272C13.8841 3.96016 13.7976 3.74388 13.6654 3.57511C13.4719 3.32808 13.2058 3.14794 12.9046 3.06005Z" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <!-- Help/question mark icon -->
            <svg class="header-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" onclick="toggleWelcomeMessage()" title="Help">
                <circle cx="12" cy="12" r="10" stroke="#000000" stroke-width="2"/>
                <path d="M9 9C9 7.34315 10.3431 6 12 6C13.6569 6 15 7.34315 15 9C15 10.6569 13.6569 12 12 12V14" stroke="#000000" stroke-width="2" stroke-linecap="round"/>
                <circle cx="12" cy="18" r="1" fill="#000000"/>
            </svg>
        </div>
        <div class="header-icons-top-right">
            <!-- Download queue icon with badge -->
            <div style="position: relative;" onclick="openDownloadQueueModal()">
                <svg class="header-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M 17.727626,19.369618 V 0.99999999 m 0,18.36961801 -5.004657,-5.009896 m 5.004657,5.009896 5.004658,-5.009896 M 1,1.7696715 H 12.200214 M 1,7.4045513 H 12.200214 M 1,13.03943 h 5.6001067" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span id="dqIconBadge" style="display: none; position: absolute; top: -4px; right: -4px; width: 10px; height: 10px; background: var(--primary-color); border-radius: 50%; animation: badgePulse 2s ease-in-out infinite;"></span>
            </div>
            <!-- Logout icon -->
            <svg class="header-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" onclick="window.location.href='/logout'" title="Logout ({{ username }})">
                <path d="M16 17L21 12M21 12L16 7M21 12H9M9 3H7.8C6.11984 3 5.27976 3 4.63803 3.32698C4.07354 3.6146 3.6146 4.07354 3.32698 4.63803C3 5.27976 3 6.11984 3 7.8V16.2C3 17.8802 3 18.7202 3.32698 19.362C3.6146 19.9265 4.07354 20.3854 4.63803 20.673C5.27976 21 6.11984 21 7.8 21H9" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </div>
        <!-- Spacer to clear header icons -->
        <div style="height: 40px;"></div>

        <!-- PWA Install Banner (shown on mobile when not installed) -->
        <div id="pwaInstallBanner" style="display: none; background: #000; padding: 10px 14px; border-radius: 6px; margin-bottom: 12px;">
            <div style="display: flex; justify-content: space-between; align-items: center; gap: 12px;">
                <span style="color: #ccc; font-size: 0.85em;">Install as app for a better experience</span>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <a href="#" onclick="openPwaInstructions(); return false;" style="color: #fff; font-size: 0.85em; text-decoration: underline;">How</a>
                    <button onclick="dismissPwaBanner()" style="background: none; border: none; color: #666; font-size: 1.1em; cursor: pointer; padding: 0;">&times;</button>
                </div>
            </div>
        </div>

        <!-- Message notifications disabled -->

        <!-- Welcome greeting -->
        <div id="welcomeGreeting" class="playlist-section" style="border-top: none; padding: 20px 15px; text-align: center;">
            <h2 id="greetingText" style="color: var(--text-color); font-weight: 400; margin: 0;"></h2>
        </div>

        <!-- Welcome/help modal -->
        <div id="welcomeModal" class="modal" style="display: none;">
            <div class="modal-content" style="max-width: 440px; padding: 0; overflow: hidden;">
                <div style="padding: 24px 24px 20px; border-bottom: 1px solid var(--border-color);">
                    <h2 style="margin: 0; font-size: 1.3em; color: var(--text-color);">Welcome to TrackDrop</h2>
                </div>
                <div style="padding: 20px 24px; max-height: 60vh; overflow-y: auto;">
                    <div style="margin-bottom: 20px;">
                        <div style="font-weight: 600; color: var(--text-color); margin-bottom: 6px; font-size: 0.95em;">Get Started</div>
                        <p style="color: var(--text-muted); margin: 0; font-size: 0.9em; line-height: 1.5;">
                            Configure your music services in Settings (gear icon) to enable automatic recommendations.
                        </p>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <div style="font-weight: 600; color: var(--text-color); margin-bottom: 6px; font-size: 0.95em;">Download Music</div>
                        <p style="color: var(--text-muted); margin: 0; font-size: 0.9em; line-height: 1.5;">
                            Paste any link from Spotify, Deezer, Tidal, YouTube, or other services to download in FLAC quality.
                        </p>
                    </div>

                    <div style="padding: 14px; background: rgba(65, 66, 224, 0.08); border-radius: 10px; border: 1px solid rgba(65, 66, 224, 0.15);">
                        <div style="font-weight: 600; color: var(--accent-color); margin-bottom: 6px; font-size: 0.95em;">Mobile App</div>
                        <p style="color: var(--text-muted); margin: 0 0 10px 0; font-size: 0.9em; line-height: 1.5;">
                            Install TrackDrop on your phone, then share links directly from any music app to start downloading.
                        </p>
                        <div style="color: var(--text-muted); font-size: 0.8em; opacity: 0.8;">
                            iOS: Share → Add to Home Screen<br>
                            Android: Menu → Install App
                        </div>
                    </div>
                </div>
                <div style="padding: 16px 24px; border-top: 1px solid var(--border-color); display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="dismissWelcomeMessage()" style="background: transparent; border: 1px solid var(--border-color); color: var(--text-color); padding: 10px 18px;">
                        Got it
                    </button>
                    <button onclick="openSettingsModal(); dismissWelcomeMessage();" style="padding: 10px 18px;">
                        Open Settings
                    </button>
                </div>
            </div>
        </div>

        <div id="downloadFromLinkSection" class="playlist-section" style="border-top: none; padding-top: 10px; margin-top: 10px;">
            <div class="form-group" style="margin-bottom: 10px;">
                <div class="download-link-row">
                    <input type="text" id="musicLinkInput" placeholder="Paste a song, album, or playlist link..." style="flex: 1; width: 100%;" onkeypress="if(event.key==='Enter')downloadFromLink()">
                    <button id="downloadLinkBtn" onclick="downloadFromLink()" style="white-space: nowrap; margin: 0;">Download</button>
                </div>
            </div>
        </div>

        <!-- Download Queue Section -->
        <div id="downloadQueueSection" class="playlist-section" style="display: none;">
            <div class="playlist-header">
                <h2>Download Queue</h2>
                <div>
                    <span id="downloadQueueStatus" class="playlist-status"></span>
                    <button id="downloadQueueToggle" class="playlist-toggle" onclick="togglePlaylist('downloadQueue')" style="display: none;">▼</button>
                </div>
            </div>
            <div id="downloadQueueContent" class="playlist-content">
                <p style="text-align: center; color: #b0b0b0;">No downloads in queue.</p>
            </div>
        </div>

    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeSettingsModal()">&times;</span>
            <h2>Settings</h2>

            <!-- Quick Actions - Fetch Recommendations -->
            <div style="margin-bottom: 20px; padding: 15px; background: rgba(65, 66, 224, 0.08); border-radius: 8px; border: 1px solid rgba(65, 66, 224, 0.2);">
                <h4 style="margin: 0 0 12px 0; color: var(--text-color);">Fetch Recommendations</h4>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button onclick="fetchListenBrainzNow()" style="flex: 1; min-width: 140px; background-color: #3a3a5a; border: 1px solid #353070;">
                        ListenBrainz
                    </button>
                    <button onclick="fetchLastFmNow()" style="flex: 1; min-width: 140px; background-color: #3a3a5a; border: 1px solid #8b3a3a;">
                        Last.fm
                    </button>
                    <button id="runNowBtnSettings" onclick="runNow()" style="flex: 1; min-width: 140px; background-color: var(--primary-color);">
                        Fetch All
                    </button>
                </div>
            </div>

            <!-- Configuration Section -->
            <div class="settings">
                <details>
                    <summary>Profile</summary>
                    <div style="padding: 15px;">
                        <div class="form-group">
                            <label for="displayName">Display Name:</label>
                            <input type="text" id="displayName" placeholder="{{ username }}">
                            <small style="color: #b0b0b0; display: block; margin-top: 4px;">
                                Customize how your name appears in greetings. Leave empty to use your username.
                            </small>
                        </div>
                        <button onclick="saveProfileSettings()">Save Profile</button>
                    </div>
                </details>

                <details>
                    <summary>Music Services</summary>
                    <div style="padding: 15px;">
                        <h3>ListenBrainz</h3>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="listenbrainzEnabled"> Enable ListenBrainz
                            </label>
                        </div>
                        <div id="listenbrainzOptions" style="display: none; padding-left: 20px; border-left: 2px solid var(--border-color); margin-left: 5px;">
                            <div class="form-group">
                                <label for="listenbrainzUser">Username:</label>
                                <input type="text" id="listenbrainzUser" placeholder="Your ListenBrainz username">
                            </div>
                            <div class="form-group">
                                <label for="listenbrainzToken">
                                    Token:
                                    <span class="help-icon" title="Get your token from https://listenbrainz.org/profile/ → Edit Profile → API Keys → Generate new token">ℹ️</span>
                                </label>
                                <input type="text" id="listenbrainzToken" placeholder="Your ListenBrainz API token">
                            </div>
                        </div>

                        <h3>Last.fm</h3>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="lastfmEnabled"> Enable Last.fm
                            </label>
                        </div>
                        <div id="lastfmOptions" style="display: none; padding-left: 20px; border-left: 2px solid var(--border-color); margin-left: 5px;">
                            <div class="form-group">
                                <label for="lastfmUsername">Username:</label>
                                <input type="text" id="lastfmUsername" placeholder="Your Last.fm username">
                            </div>
                        </div>

                        <button onclick="saveUserSettings()">Save Settings</button>
                    </div>
                </details>

                <details>
                    <summary>Scheduled Recommendations</summary>
                    <div style="padding: 15px;">
                        <small style="color: #b0b0b0; display: block; margin-bottom: 12px;">
                            Automatically download recommendations from ListenBrainz and Last.fm on a weekly schedule.
                        </small>
                        <div class="form-group">
                            <label for="cronInput">Schedule:</label>
                            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                                <select id="cronHour" style="padding: 8px; border-radius: 4px; background-color: #3a3a5a; color: var(--text-color); border: 1px solid var(--border-color);">
                                    {% for hour in range(24) %}
                                    <option value="{{ hour }}" {% if hour == cron_hour %}selected{% endif %}>{{ "%02d"|format(hour) }}</option>
                                    {% endfor %}
                                </select>
                                :
                                <select id="cronMinute" style="padding: 8px; border-radius: 4px; background-color: #3a3a5a; color: var(--text-color); border: 1px solid var(--border-color);">
                                    {% for minute in range(0, 60, 5) %}
                                    <option value="{{ minute }}" {% if minute == cron_minute %}selected{% endif %}>{{ "%02d"|format(minute) }}</option>
                                    {% endfor %}
                                </select>
                                <select id="cronDay" style="padding: 8px; border-radius: 4px; background-color: #3a3a5a; color: var(--text-color); border: 1px solid var(--border-color);">
                                    <option value="0" {% if cron_day == 0 %}selected{% endif %}>Sunday</option>
                                    <option value="1" {% if cron_day == 1 %}selected{% endif %}>Monday</option>
                                    <option value="2" {% if cron_day == 2 %}selected{% endif %}>Tuesday</option>
                                    <option value="3" {% if cron_day == 3 %}selected{% endif %}>Wednesday</option>
                                    <option value="4" {% if cron_day == 4 %}selected{% endif %}>Thursday</option>
                                    <option value="5" {% if cron_day == 5 %}selected{% endif %}>Friday</option>
                                    <option value="6" {% if cron_day == 6 %}selected{% endif %}>Saturday</option>
                                </select>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <label for="cronTimezone" style="font-size: 0.9em;">Timezone:</label>
                                <select id="cronTimezone" style="padding: 8px; border-radius: 4px; background-color: #3a3a5a; color: var(--text-color); border: 1px solid var(--border-color); width: 100%; margin-top: 4px;">
                                    {% for tz in timezones %}
                                    <option value="{{ tz }}" {% if tz == cron_timezone %}selected{% endif %}>{{ tz }}</option>
                                    {% endfor %}
                                </select>
                                <small style="color: #b0b0b0; display: block; margin-top: 4px;">
                                    Select your local timezone. The schedule will be converted to UTC for the container.
                                </small>
                            </div>
                            <input type="hidden" id="cronInput" value="{{ cron_schedule }}">
                        </div>

                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="disableCron" {% if not cron_enabled %}checked{% endif %}>
                                Disable Scheduled Downloads
                            </label>
                        </div>

                        <button onclick="saveAutomationOptions()">Save Schedule</button>
                    </div>
                </details>

                <details>
                    <summary>Experimental Features</summary>
                    <div style="padding: 15px;">
                        <div style="background: rgba(255, 180, 0, 0.1); border: 1px solid rgba(255, 180, 0, 0.3); border-radius: 8px; padding: 12px; margin-bottom: 15px;">
                            <p style="color: #ffb400; margin: 0; font-size: 0.9em;">
                                These features are experimental and may change or be removed in future updates.
                            </p>
                        </div>
                        <div class="form-group">
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="checkbox" id="experimentalFeaturesEnabled" onchange="toggleExperimentalFeatures()">
                                Enable Experimental Features
                            </label>
                            <small style="color: #b0b0b0; display: block; margin-top: 8px; padding-left: 26px;">
                                Enables playlist monitoring and custom playlist naming when downloading playlists.
                            </small>
                        </div>
                        <button onclick="saveExperimentalSettings()">Save</button>
                    </div>
                </details>

                <details id="monitoredPlaylistsSection" style="display: none;">
                    <summary>Monitored Playlists</summary>
                    <div style="padding: 15px;">
                        <small style="color: #b0b0b0; display: block; margin-bottom: 12px;">
                            Playlists below are automatically checked for new tracks at their configured interval.
                        </small>
                        <div id="monitoredPlaylistsList" class="mp-list">
                            <p style="color: #666; font-size: 0.9em;">Loading...</p>
                        </div>
                    </div>
                </details>

                <details>
                    <summary>Mobile Apps</summary>
                    <div style="padding: 15px;">
                        <h3>Android</h3>
                        <p style="color: #b0b0b0; margin-bottom: 10px;">Install this site as a PWA (Progressive Web App) to share links directly:</p>
                        <ol style="color: #b0b0b0; margin-left: 20px; margin-bottom: 15px;">
                            <li>In Chrome, tap the menu (⋮) and select "Add to Home screen"</li>
                            <li>Once installed, share any music link and select TrackDrop from the share sheet</li>
                        </ol>

                        <h3>iOS (iPhone/iPad)</h3>
                        <p style="color: #b0b0b0; margin-bottom: 10px;">Use iOS Shortcuts to share links directly to TrackDrop:</p>
                        <a href="/ios-shortcut" target="_blank" style="display: inline-block; background: var(--primary-color); color: white; padding: 10px 20px; border-radius: 8px; text-decoration: none; margin-bottom: 10px;">Set Up iOS Shortcut</a>
                        <p style="color: #888; font-size: 0.85em;">Opens a page with setup instructions and your personal API key.</p>
                    </div>
                </details>

                <details>
                    <summary>Library Maintenance</summary>
                    <div style="padding: 15px;">
                        <h3>Cleanup 1-Star Songs</h3>
                        <p style="color: #b0b0b0; margin-bottom: 15px;">
                            Scan your entire library for songs you've rated 1 star and remove them.
                            Songs will only be deleted if no other user has favorited them, added them to a playlist, or given them a higher rating.
                        </p>
                        <button onclick="triggerManualCleanup()" style="background-color: #c0392b;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" style="vertical-align: middle; margin-right: 6px;">
                                <path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14zM10 11v6M14 11v6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            Cleanup Now
                        </button>
                        <p style="color: #888; font-size: 0.85em; margin-top: 10px;">
                            <strong>Note:</strong> This scans all songs in your library, not just auto-downloaded recommendations.
                            Auto-downloaded songs are automatically cleaned up based on their ratings during the scheduled cleanup.
                        </p>
                    </div>
                </details>
            </div>
        </div>
    </div>

    <!-- Download Queue Panel -->
    <div id="downloadQueuePanel" class="download-queue-modal">
        <div class="dq-collapse-handle" onclick="closeDownloadQueuePanel()" title="Collapse">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M9 18L15 12L9 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </div>
        <div class="modal-content">
            <div class="dq-header">
                <h2>DOWNLOADS</h2>
                <span id="dqBadge" class="dq-header-badge" style="display: none;">0 active</span>
            </div>
            <div id="downloadQueueModalContent" style="flex-grow: 1; overflow-y: auto;">
                <div class="dq-empty">
                    <svg class="dq-empty-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M 17.727626,19.369618 V 0.99999999 m 0,18.36961801 -5.004657,-5.009896 m 5.004657,5.009896 5.004658,-5.009896 M 1,1.7696715 H 12.200214 M 1,7.4045513 H 12.200214 M 1,13.03943 h 5.6001067" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    <p>No downloads in queue</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Playlist download mode popup -->
    <div id="playlistModeOverlay" class="pl-popup-overlay">
        <div class="pl-popup">
            <h3>Download Playlist</h3>

            <!-- Playlist name input -->
            <div style="margin-bottom: 12px;">
                <label style="font-size: 0.85em; color: #b0b0b0; display: block; margin-bottom: 4px;">Playlist name</label>
                <input type="text" id="playlistNameInput" style="width: 100%; padding: 10px; border-radius: 6px; background: #3a3a5a; color: var(--text-color); border: 1px solid var(--border-color); box-sizing: border-box; font-size: 1em;" placeholder="Playlist name">
            </div>

            <!-- URL and track count -->
            <p id="playlistModeUrl" style="font-size: 0.8em; color: #888; word-break: break-all; margin-bottom: 4px;"></p>
            <p id="playlistModeTrackCount" style="font-size: 0.85em; color: #b0b0b0; margin-bottom: 12px;"></p>

            <!-- Status message for name conflicts / monitoring -->
            <div id="playlistStatusMessage" style="display: none; margin-bottom: 14px; padding: 10px; border-radius: 8px; font-size: 0.9em;"></div>

            <!-- Monitoring toggle -->
            <div style="margin-bottom: 14px;">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 0.95em;">
                    <input type="checkbox" id="playlistMonitorToggle" style="width: 18px; height: 18px;">
                    Monitor for new tracks
                </label>
            </div>

            <!-- Monitoring options (shown when toggle is checked) -->
            <div id="playlistMonitorOptions" style="display: none; margin-bottom: 14px; padding: 12px; background: rgba(100,100,150,0.1); border-radius: 8px; border: 1px solid rgba(100,100,150,0.2);">
                <label style="font-size: 0.85em; display: flex; align-items: center; gap: 8px;">
                    Check for new tracks every:
                    <select id="playlistPollInterval" style="padding: 4px 8px; border-radius: 4px; background: #3a3a5a; color: var(--text-color); border: 1px solid var(--border-color);">
                        <option value="6">6 hours</option>
                        <option value="12">12 hours</option>
                        <option value="24" selected>24 hours</option>
                        <option value="48">2 days</option>
                        <option value="168">Weekly</option>
                    </select>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; margin-top: 10px; font-size: 0.85em; cursor: pointer;">
                    <input type="checkbox" id="playlistAutoCleanup">
                    Auto-cleanup old tracks on sync
                    <span title="When enabled, tracks removed from the playlist will be deleted from your library (unless starred, rated, or in other playlists)" style="cursor: help; opacity: 0.6;">?</span>
                </label>
            </div>

            <!-- Download button -->
            <button id="playlistDownloadBtn" class="btn-once" style="width: 100%; padding: 12px; font-size: 1em;">
                Download
            </button>
        </div>
    </div>

    <!-- Custom Confirmation Dialog -->
    <div id="confirmDialog" class="pl-popup-overlay">
        <div class="pl-popup" style="max-width: 400px;">
            <h3 id="confirmDialogTitle">Confirm</h3>
            <p id="confirmDialogMessage" style="color: #b0b0b0; margin-bottom: 20px;"></p>
            <div style="display: flex; gap: 12px;">
                <button id="confirmDialogCancel" style="flex: 1; padding: 12px; background: #3a3a5a; border: 1px solid var(--border-color);">
                    Cancel
                </button>
                <button id="confirmDialogOk" style="flex: 1; padding: 12px;">
                    Confirm
                </button>
            </div>
        </div>
    </div>

    <script>
        // Welcome greetings with {name} placeholder
        const GREETINGS = [
            "What are we listening to today, {name}?",
            "Ready to discover something new, {name}?",
            "What's on your playlist today, {name}?",
            "Let's find your next favorite song, {name}!",
            "Welcome back, {name}!",
            "Hey {name}, let's drop some tracks!",
            "Good vibes only, {name}!",
            "What sounds good today, {name}?",
            "Time to expand your library, {name}!",
            "Music awaits, {name}!",
            "Let's get the party started, {name}!",
            "Discover. Download. Enjoy. Right, {name}?",
            "Your personal DJ is ready, {name}!",
            "What's the soundtrack of your day, {name}?",
            "New music, who dis? Oh hey, {name}!",
        ];

        // Display name (loaded from settings)
        let userDisplayName = "{{ display_name or username }}";

        // Experimental features state
        let experimentalFeaturesEnabled = false;

        // PWA detection and install banner
        function isPwaInstalled() {
            // Check if running in standalone mode (PWA)
            return window.matchMedia('(display-mode: standalone)').matches ||
                   window.navigator.standalone === true ||
                   document.referrer.includes('android-app://');
        }

        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   (window.innerWidth <= 768);
        }

        function checkPwaBanner() {
            const banner = document.getElementById('pwaInstallBanner');
            if (!banner) return;

            // Check if user dismissed the banner before
            const dismissed = localStorage.getItem('pwaBannerDismissed');
            if (dismissed) {
                banner.style.display = 'none';
                return;
            }

            // Show banner only on mobile when not installed as PWA
            if (isMobileDevice() && !isPwaInstalled()) {
                banner.style.display = 'block';
            } else {
                banner.style.display = 'none';
            }
        }

        function dismissPwaBanner() {
            const banner = document.getElementById('pwaInstallBanner');
            if (banner) banner.style.display = 'none';
            localStorage.setItem('pwaBannerDismissed', 'true');
        }

        function openPwaInstructions() {
            // Open settings modal and scroll to Mobile Apps section
            openSettingsModal();
            setTimeout(() => {
                const mobileAppsDetails = document.querySelector('details summary');
                const allDetails = document.querySelectorAll('.settings details');
                allDetails.forEach(d => {
                    if (d.querySelector('summary').textContent.includes('Mobile Apps')) {
                        d.open = true;
                        d.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                });
            }, 100);
        }

        // Check PWA banner on page load
        document.addEventListener('DOMContentLoaded', checkPwaBanner);

        // Custom confirmation dialog
        function showConfirmDialog(title, message, onConfirm, onCancel) {
            const overlay = document.getElementById('confirmDialog');
            document.getElementById('confirmDialogTitle').textContent = title;
            document.getElementById('confirmDialogMessage').textContent = message;

            const okBtn = document.getElementById('confirmDialogOk');
            const cancelBtn = document.getElementById('confirmDialogCancel');

            // Remove old listeners
            const newOkBtn = okBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            okBtn.parentNode.replaceChild(newOkBtn, okBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            newOkBtn.addEventListener('click', () => {
                overlay.classList.remove('open');
                if (onConfirm) onConfirm();
            });

            newCancelBtn.addEventListener('click', () => {
                overlay.classList.remove('open');
                if (onCancel) onCancel();
            });

            overlay.classList.add('open');
        }

        function toggleExperimentalFeatures() {
            const enabled = document.getElementById('experimentalFeaturesEnabled').checked;
            document.getElementById('monitoredPlaylistsSection').style.display = enabled ? 'block' : 'none';
        }

        async function saveExperimentalSettings() {
            const enabled = document.getElementById('experimentalFeaturesEnabled').checked;
            try {
                const response = await fetch('/api/user/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ experimental_features_enabled: enabled })
                });
                const data = await response.json();
                showMessage(data.status, data.message);
                if (data.status === 'success') {
                    experimentalFeaturesEnabled = enabled;
                    document.getElementById('monitoredPlaylistsSection').style.display = enabled ? 'block' : 'none';
                }
            } catch (error) {
                showMessage('error', 'Failed to save settings');
            }
        }

        function showRandomGreeting() {
            const greeting = GREETINGS[Math.floor(Math.random() * GREETINGS.length)];
            const greetingEl = document.getElementById('greetingText');
            if (greetingEl) {
                greetingEl.textContent = greeting.replace('{name}', userDisplayName);
            }
        }

        // Initialize greeting on page load
        // First-time setup flag from server
        const isFirstTime = {{ 'true' if first_time else 'false' }};

        document.addEventListener('DOMContentLoaded', () => {
            showRandomGreeting();
            // Auto-show welcome modal for first-time users
            if (isFirstTime) {
                document.getElementById('welcomeModal').style.display = 'block';
            }
        });

        function toggleWelcomeMessage() {
            const modal = document.getElementById('welcomeModal');
            modal.style.display = modal.style.display === 'block' ? 'none' : 'block';
        }

        function dismissWelcomeMessage() {
            document.getElementById('welcomeModal').style.display = 'none';
            // Mark first-time setup as done so it doesn't show again
            if (isFirstTime) {
                fetch('/api/user/setup_done', { method: 'POST' }).catch(() => {});
            }
        }

        function openSettingsModal() {
            document.getElementById('settingsModal').style.display = 'block';
            loadUserSettings();
            loadConfiguration();
            loadMonitoredPlaylists();
        }

        function closeSettingsModal() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        function openDownloadQueueModal() {
            const downloadQueuePanel = document.getElementById('downloadQueuePanel');
            if (downloadQueuePanel.classList.contains('open')) {
                closeDownloadQueuePanel(); // Close if already open
            } else {
                downloadQueuePanel.classList.add('open');
                document.body.classList.add('download-queue-panel-open'); // Add class to body
                fetchDownloadQueueStatus(); // Load queue status when panel opens
            }
        }

        function closeDownloadQueuePanel() {
            document.getElementById('downloadQueuePanel').classList.remove('open');
            document.body.classList.remove('download-queue-panel-open'); // Remove class from body
        }

        // Functions to toggle visibility of dependent settings
        function updateListenBrainzVisibility() {
            const isEnabled = document.getElementById('listenbrainzEnabled').checked;
            document.getElementById('listenbrainzOptions').style.display = isEnabled ? 'block' : 'none';
        }

        function updateLastFmVisibility() {
            const isEnabled = document.getElementById('lastfmEnabled').checked;
            document.getElementById('lastfmOptions').style.display = isEnabled ? 'block' : 'none';
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('listenbrainzEnabled').addEventListener('change', updateListenBrainzVisibility);
            document.getElementById('lastfmEnabled').addEventListener('change', updateLastFmVisibility);
        });        // Close modals when clicking outside of them
        window.onclick = function(event) {
            const settingsModal = document.getElementById('settingsModal');
            // Check if settings modal needs to be closed
            if (event.target == settingsModal) {
                settingsModal.style.display = 'none';
            }
            // Removed logic to close downloadQueuePanel on outside click as per user feedback.
            // Only the queue button should close it now.
        }

        function togglePlaylist(service) {
            const contentDiv = document.getElementById(`${service}Playlist`);
            const toggleBtn = document.getElementById(`${service}Toggle`);
            if (contentDiv.classList.contains('collapsed')) {
                contentDiv.classList.remove('collapsed');
                toggleBtn.textContent = '▼';
            } else {
                contentDiv.classList.add('collapsed');
                toggleBtn.textContent = '▶';
            }
        }


// Store pending deletions for confirmation
let pendingCleanupSongIds = [];

async function triggerManualCleanup() {
    const button = event.target.closest('button');
    const originalContent = button.innerHTML;
    button.innerHTML = '<div class="spinner"></div> Scanning...';
    button.disabled = true;

    try {
        // Step 1: Get preview of what would be deleted
        const response = await fetch('/api/manual_cleanup/preview', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        });
        const data = await response.json();

        if (data.status === 'success') {
            // Show confirmation dialog
            showCleanupConfirmation(data);
        } else {
            showMessage('error', data.message);
        }
    } catch (error) {
        console.error('Manual cleanup preview error:', error);
        showMessage('error', 'Failed to scan library: ' + error.message);
    } finally {
        button.innerHTML = originalContent;
        button.disabled = false;
    }
}

function showCleanupConfirmation(data) {
    // Store song IDs for deletion
    pendingCleanupSongIds = data.to_delete.map(s => s.navidrome_id);

    // Create modal overlay
    const overlay = document.createElement('div');
    overlay.id = 'cleanup-confirm-modal';
    overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);display:flex;align-items:center;justify-content:center;z-index:1000;';

    const modal = document.createElement('div');
    modal.style.cssText = 'background:var(--card-background);border-radius:12px;padding:24px;max-width:600px;max-height:80vh;overflow-y:auto;color:var(--text-color);min-width:400px;border:1px solid var(--border-color);box-shadow:0 8px 32px rgba(0,0,0,0.5);';

    let contentHtml = `
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;padding-bottom:15px;border-bottom:1px solid var(--border-color);">
            <h3 style="margin:0;color:var(--primary-color);font-size:1.3em;">Cleanup Preview</h3>
            <button onclick="document.getElementById('cleanup-confirm-modal').remove()" style="background:none;border:none;color:var(--text-color);font-size:24px;cursor:pointer;opacity:0.7;transition:opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'">&times;</button>
        </div>
        <p style="margin-bottom:20px;color:#b0b0b0;">Found <strong style="color:var(--text-color);">${data.scanned}</strong> songs you rated 1 star or less.</p>
    `;

    if (data.to_delete.length > 0) {
        contentHtml += `<div style="margin-bottom:20px;padding:15px;background:#3a2020;border-radius:8px;border:1px solid #5a3030;">
            <strong style="color:#ff6b6b;display:block;margin-bottom:10px;">⚠ Will be deleted (${data.to_delete.length}):</strong>
            <ul style="margin:0;padding-left:20px;list-style-type:none;">`;
        data.to_delete.forEach(song => {
            contentHtml += `<li style="margin:8px 0;padding:8px;background:rgba(0,0,0,0.2);border-radius:4px;">
                <span style="color:var(--text-color);">${song.artist} - ${song.title}</span>
                <span style="color:#666;font-size:0.9em;"> [${song.album}]</span>
            </li>`;
        });
        contentHtml += `</ul></div>`;
    }

    if (data.to_keep.length > 0) {
        contentHtml += `<div style="margin-bottom:20px;padding:15px;background:#203a20;border-radius:8px;border:1px solid #305a30;">
            <strong style="color:#6bff6b;display:block;margin-bottom:10px;">✓ Will be kept (${data.to_keep.length}):</strong>
            <ul style="margin:0;padding-left:20px;list-style-type:none;">`;
        data.to_keep.forEach(song => {
            contentHtml += `<li style="margin:8px 0;padding:8px;background:rgba(0,0,0,0.2);border-radius:4px;">
                <span style="color:var(--text-color);">${song.artist} - ${song.title}</span>
                <span style="color:#666;font-size:0.9em;"> [${song.album}]</span>
                <div style="font-size:0.85em;color:#888;margin-top:4px;font-style:italic;">↳ ${song.reason}</div>
            </li>`;
        });
        contentHtml += `</ul></div>`;
    }

    if (data.to_delete.length === 0 && data.to_keep.length === 0) {
        contentHtml += `<p style="color:#888;text-align:center;padding:20px;">No low-rated songs found in your library.</p>`;
    }

    if (data.errors && data.errors.length > 0) {
        contentHtml += `<div style="margin-top:15px;padding:10px;background:#4a3030;border-radius:6px;"><span style="color:#ff6b6b;">Errors:</span> ${data.errors.join(', ')}</div>`;
    }

    contentHtml += `<div style="margin-top:24px;display:flex;gap:12px;justify-content:flex-end;padding-top:15px;border-top:1px solid var(--border-color);">`;
    contentHtml += `<button onclick="document.getElementById('cleanup-confirm-modal').remove()" style="padding:12px 24px;background:#3a3a5a;color:var(--text-color);border:1px solid var(--border-color);border-radius:6px;cursor:pointer;transition:background 0.2s;" onmouseover="this.style.background='#4a4a6a'" onmouseout="this.style.background='#3a3a5a'">Cancel</button>`;

    if (data.to_delete.length > 0) {
        contentHtml += `<button onclick="executeManualCleanup()" style="padding:12px 24px;background:#c0392b;color:white;border:none;border-radius:6px;cursor:pointer;font-weight:600;transition:background 0.2s;" onmouseover="this.style.background='#e74c3c'" onmouseout="this.style.background='#c0392b'">Delete ${data.to_delete.length} Songs</button>`;
    }
    contentHtml += `</div>`;

    modal.innerHTML = contentHtml;
    overlay.appendChild(modal);
    overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
    document.body.appendChild(overlay);
}

async function executeManualCleanup() {
    const modal = document.getElementById('cleanup-confirm-modal');
    const buttons = modal.querySelectorAll('button');
    buttons.forEach(b => b.disabled = true);

    // Find the delete button and show spinner
    const deleteBtn = Array.from(buttons).find(b => b.textContent.includes('Delete'));
    if (deleteBtn) {
        deleteBtn.innerHTML = '<div class="spinner" style="width:16px;height:16px;display:inline-block;margin-right:8px;"></div>Deleting...';
    }

    try {
        const response = await fetch('/api/manual_cleanup', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ song_ids: pendingCleanupSongIds })
        });
        const data = await response.json();

        // Close confirmation modal
        modal.remove();

        if (data.status === 'success') {
            // Show results
            showCleanupResults(data);
            showMessage('success', data.message);
        } else {
            showMessage('error', data.message);
        }
    } catch (error) {
        console.error('Manual cleanup error:', error);
        showMessage('error', 'Failed to delete songs: ' + error.message);
        modal.remove();
    }

    pendingCleanupSongIds = [];
}

function showCleanupResults(data) {
    const overlay = document.createElement('div');
    overlay.id = 'cleanup-results-modal';
    overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);display:flex;align-items:center;justify-content:center;z-index:1000;';

    const modal = document.createElement('div');
    modal.style.cssText = 'background:var(--card-background);border-radius:12px;padding:24px;max-width:500px;max-height:80vh;overflow-y:auto;color:var(--text-color);min-width:350px;border:1px solid var(--border-color);box-shadow:0 8px 32px rgba(0,0,0,0.5);';

    let contentHtml = `
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;padding-bottom:15px;border-bottom:1px solid var(--border-color);">
            <h3 style="margin:0;color:var(--primary-color);font-size:1.3em;">✓ Cleanup Complete</h3>
            <button onclick="document.getElementById('cleanup-results-modal').remove()" style="background:none;border:none;color:var(--text-color);font-size:24px;cursor:pointer;opacity:0.7;transition:opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'">&times;</button>
        </div>
    `;

    if (data.deleted && data.deleted.length > 0) {
        contentHtml += `<div style="margin-bottom:20px;padding:15px;background:#203a20;border-radius:8px;border:1px solid #305a30;">
            <strong style="color:#6bff6b;display:block;margin-bottom:10px;">Deleted ${data.deleted.length} songs:</strong>
            <ul style="margin:0;padding-left:20px;list-style-type:none;">`;
        data.deleted.forEach(song => {
            contentHtml += `<li style="margin:6px 0;padding:6px 8px;background:rgba(0,0,0,0.2);border-radius:4px;">${song.artist} - ${song.title}</li>`;
        });
        contentHtml += `</ul></div>`;
    } else {
        contentHtml += `<p style="color:#888;text-align:center;padding:20px;">No songs were deleted.</p>`;
    }

    if (data.errors && data.errors.length > 0) {
        contentHtml += `<div style="margin-bottom:20px;padding:15px;background:#3a2020;border-radius:8px;border:1px solid #5a3030;">
            <strong style="color:#ff6b6b;display:block;margin-bottom:10px;">Errors:</strong>
            <ul style="margin:0;padding-left:20px;list-style-type:none;">`;
        data.errors.forEach(err => {
            contentHtml += `<li style="margin:6px 0;padding:6px 8px;background:rgba(0,0,0,0.2);border-radius:4px;font-size:0.9em;">${err}</li>`;
        });
        contentHtml += `</ul></div>`;
    }

    contentHtml += `<div style="margin-top:20px;padding-top:15px;border-top:1px solid var(--border-color);text-align:right;">
        <button onclick="document.getElementById('cleanup-results-modal').remove()" style="padding:12px 24px;background:var(--primary-color);color:white;border:none;border-radius:6px;cursor:pointer;font-weight:600;transition:filter 0.2s;" onmouseover="this.style.filter='brightness(1.2)'" onmouseout="this.style.filter='none'">Close</button>
    </div>`;

    modal.innerHTML = contentHtml;
    overlay.appendChild(modal);
    overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
    document.body.appendChild(overlay);
}

        // --- Download Queue Functions ---
        const downloadQueue = []; // In-memory queue for display
        let downloadQueueInterval = null;

        // Track which track lists are expanded (persists across re-renders)
        const expandedItems = new Set();

        function _statusIcon(status, size = 24) {
            if (status === 'in_progress') return `<div class="spinner" style="width:${size}px;height:${size}px;"></div>`;
            if (status === 'completed' || status === 'skipped') return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none"><path d="M4 12.6111L8.92308 17.5L20 6.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
            if (status === 'failed') return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none"><path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
            if (status === 'pending') return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="3" fill="#666"/></svg>`;
            return '';
        }

        function _trackStatusColor(status) {
            if (status === 'completed') return 'var(--success-color)';
            if (status === 'skipped') return 'var(--secondary-color)';
            if (status === 'failed') return 'var(--error-color)';
            if (status === 'in_progress') return 'var(--info-color)';
            return '#666';
        }

        function _escHtml(s) {
            const d = document.createElement('div');
            d.textContent = s || '';
            return d.innerHTML;
        }

        function toggleTrackList(itemId) {
            if (expandedItems.has(itemId)) expandedItems.delete(itemId);
            else expandedItems.add(itemId);
            updateDownloadQueueUI();
        }

        function renderPlaylistItem(item, animate = false) {
            const tracks = item.tracks || [];
            const total = item.total_track_count || tracks.length || 0;
            const dl = item.downloaded_count || 0;
            const skip = item.skipped_count || 0;
            const fail = item.failed_count || 0;
            const cleanupDeleted = item.cleanup_deleted || 0;
            const processed = dl + skip + fail;
            const pending = Math.max(0, total - processed);
            const pct = total > 0 ? Math.round((processed / total) * 100) : 0;
            const isExpanded = expandedItems.has(item.id);
            const sourceStats = item.source_stats || {};

            // Progress bar gradient based on status
            let barStyle = 'background: linear-gradient(90deg, var(--info-color), var(--primary-color));';
            if (item.status === 'completed') barStyle = 'background: linear-gradient(90deg, var(--success-color), #00b87a);';
            else if (item.status === 'failed') barStyle = 'background: var(--error-color);';

            // Build source stats display
            let sourceStatsHtml = '';
            const sourceEntries = Object.entries(sourceStats);
            if (sourceEntries.length > 0) {
                sourceStatsHtml = `
                    <div class="dq-source-stats">
                        ${sourceEntries.map(([src, stats]) => {
                            const apiCount = stats.api_count || 0;
                            const finalCount = stats.final_count !== undefined ? stats.final_count : apiCount;
                            const dedupNote = finalCount !== apiCount ? ` → ${finalCount}` : '';
                            return `<span style="display: flex; align-items: center; gap: 6px;">
                                <span style="width: 6px; height: 6px; border-radius: 50%; background-color: var(--text-muted);"></span>
                                ${_escHtml(src)}: ${apiCount}${dedupNote}
                            </span>`;
                        }).join('')}
                    </div>
                `;
            }

            let trackListHtml = '';
            if (tracks.length > 0) {
                trackListHtml = `
                    <button class="dq-expand-btn" onclick="toggleTrackList('${item.id}')">
                        ${isExpanded ? '▼ HIDE TRACKS' : '▶ SHOW TRACKS (' + tracks.length + ')'}
                    </button>
                    <div class="dq-track-list ${isExpanded ? 'open' : ''}" data-item-id="${item.id}">
                        ${tracks.map(t => `
                            <div class="dq-track-entry">
                                <span class="dq-track-status-icon" style="color: ${_trackStatusColor(t.status)}">${_statusIcon(t.status, 14)}</span>
                                <span class="dq-track-label">${_escHtml(t.artist)} — ${_escHtml(t.title)}</span>
                                <span class="dq-track-msg">${_escHtml(t.message)}</span>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            // Status message styling
            const msgColor = item.status === 'failed' ? 'var(--error-color)' : item.status === 'completed' ? 'var(--success-color)' : 'var(--text-muted)';
            const animClass = animate ? ' dq-animate-in' : '';

            return `
                <div class="download-queue-item ${item.status}${animClass}" data-item-id="${item.id}">
                    <div class="download-queue-item-header">
                        <div class="track-info">
                            <div class="track-title">${_escHtml(item.title)}</div>
                            ${item.message ? `<div class="dq-message" style="font-family: var(--font-mono); font-size: 0.75em; margin-top: 4px; color: ${msgColor};">${_escHtml(item.message)}</div>` : ''}
                        </div>
                        <div class="status-icon ${item.status}">
                            ${_statusIcon(item.status)}
                        </div>
                    </div>
                    ${sourceStatsHtml}
                    ${total > 0 ? `
                        <div class="dq-progress-bar">
                            <div class="dq-progress-bar-inner" style="width: ${pct}%; ${barStyle}"></div>
                        </div>
                        <div class="dq-stats">
                            ${dl > 0 ? `<span class="dq-stat"><span class="dq-stat-dot downloaded"></span>${dl} downloaded</span>` : ''}
                            ${skip > 0 ? `<span class="dq-stat"><span class="dq-stat-dot skipped"></span>${skip} in library</span>` : ''}
                            ${fail > 0 ? `<span class="dq-stat"><span class="dq-stat-dot failed"></span>${fail} failed</span>` : ''}
                            ${cleanupDeleted > 0 ? `<span class="dq-stat"><span class="dq-stat-dot" style="background-color: var(--warning-color); box-shadow: 0 0 6px rgba(255, 180, 0, 0.5);"></span>${cleanupDeleted} removed</span>` : ''}
                            ${pending > 0 && item.status === 'in_progress' ? `<span class="dq-stat"><span class="dq-stat-dot pending"></span>${pending} remaining</span>` : ''}
                        </div>
                    ` : ''}
                    ${trackListHtml}
                </div>
            `;
        }

        function renderSimpleItem(item, animate = false) {
            const msgColor = item.status === 'failed' ? 'var(--error-color)' : item.status === 'completed' ? 'var(--success-color)' : 'var(--text-muted)';
            const animClass = animate ? ' dq-animate-in' : '';
            return `
                <div class="download-queue-item ${item.status}${animClass}" data-item-id="${item.id}">
                    <div class="download-queue-item-header">
                        <div class="track-info">
                            <div class="track-title">${_escHtml(item.title)}</div>
                            <div style="font-family: var(--font-mono); font-size: 0.8em; color: var(--text-muted); margin-top: 2px;">${_escHtml(item.artist)}</div>
                            ${item.message ? `<div class="dq-message" style="font-family: var(--font-mono); font-size: 0.75em; margin-top: 4px; color: ${msgColor};">${_escHtml(item.message)}</div>` : ''}
                        </div>
                        <div class="status-icon ${item.status}">
                            ${_statusIcon(item.status)}
                        </div>
                    </div>
                </div>
            `;
        }

        // Track rendered items to avoid re-animating
        const renderedItemIds = new Set();

        function updateDownloadQueueUI() {
            const queueContent = document.getElementById('downloadQueueModalContent');
            const badge = document.getElementById('dqBadge');
            const iconBadge = document.getElementById('dqIconBadge');
            if (!queueContent) return;

            // Update badges
            const activeCount = downloadQueue.filter(item => item.status === 'in_progress').length;

            if (iconBadge) {
                iconBadge.style.display = activeCount > 0 ? 'block' : 'none';
            }

            if (badge) {
                if (activeCount > 0) {
                    badge.textContent = `${activeCount} active`;
                    badge.style.display = 'inline-block';
                } else if (downloadQueue.length > 0) {
                    badge.textContent = `${downloadQueue.length} total`;
                    badge.style.display = 'inline-block';
                } else {
                    badge.style.display = 'none';
                }
            }

            // Show empty state
            if (downloadQueue.length === 0) {
                renderedItemIds.clear();
                queueContent.innerHTML = `
                    <div class="dq-empty">
                        <svg class="dq-empty-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M 17.727626,19.369618 V 0.99999999 m 0,18.36961801 -5.004657,-5.009896 m 5.004657,5.009896 5.004658,-5.009896 M 1,1.7696715 H 12.200214 M 1,7.4045513 H 12.200214 M 1,13.03943 h 5.6001067" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <p>No downloads in queue</p>
                    </div>
                `;
                return;
            }

            // Get current item IDs in the queue
            const currentIds = new Set(downloadQueue.map(item => item.id));

            // Remove items that are no longer in the queue
            queueContent.querySelectorAll('.download-queue-item').forEach(el => {
                const itemId = el.dataset.itemId;
                if (itemId && !currentIds.has(itemId)) {
                    el.remove();
                    renderedItemIds.delete(itemId);
                }
            });

            // Update or add items
            downloadQueue.forEach((item, index) => {
                const existingEl = queueContent.querySelector(`.download-queue-item[data-item-id="${item.id}"]`);

                if (existingEl) {
                    // Update existing item in place
                    updateExistingItem(existingEl, item);
                } else {
                    // Add new item with animation
                    const isNew = !renderedItemIds.has(item.id);
                    const html = (item.download_type === 'playlist' || (item.tracks && item.tracks.length > 0))
                        ? renderPlaylistItem(item, isNew)
                        : renderSimpleItem(item, isNew);

                    // Find the correct position to insert
                    const nextSibling = queueContent.children[index];
                    if (nextSibling) {
                        nextSibling.insertAdjacentHTML('beforebegin', html);
                    } else {
                        queueContent.insertAdjacentHTML('beforeend', html);
                    }
                    renderedItemIds.add(item.id);
                }
            });

            // Remove empty state if present
            const emptyState = queueContent.querySelector('.dq-empty');
            if (emptyState) emptyState.remove();
        }

        function updateExistingItem(el, item) {
            // Update status class
            el.className = `download-queue-item ${item.status}`;

            // Update status icon
            const statusIcon = el.querySelector('.status-icon');
            if (statusIcon) {
                statusIcon.className = `status-icon ${item.status}`;
                statusIcon.innerHTML = _statusIcon(item.status);
            }

            // Update message
            const msgColor = item.status === 'failed' ? 'var(--error-color)' : item.status === 'completed' ? 'var(--success-color)' : 'var(--text-muted)';
            let msgEl = el.querySelector('.dq-message');
            if (item.message) {
                if (msgEl) {
                    msgEl.textContent = item.message;
                    msgEl.style.color = msgColor;
                } else {
                    const trackInfo = el.querySelector('.track-info');
                    if (trackInfo) {
                        trackInfo.insertAdjacentHTML('beforeend', `<div class="dq-message" style="font-family: var(--font-mono); font-size: 0.75em; margin-top: 4px; color: ${msgColor};">${_escHtml(item.message)}</div>`);
                    }
                }
            } else if (msgEl) {
                msgEl.remove();
            }

            // Update progress bar
            const tracks = item.tracks || [];
            const total = item.total_track_count || tracks.length || 0;
            const dl = item.downloaded_count || 0;
            const skip = item.skipped_count || 0;
            const fail = item.failed_count || 0;
            const processed = dl + skip + fail;
            const pct = total > 0 ? Math.round((processed / total) * 100) : 0;

            const progressInner = el.querySelector('.dq-progress-bar-inner');
            if (progressInner) {
                progressInner.style.width = `${pct}%`;
                if (item.status === 'completed') {
                    progressInner.style.background = 'linear-gradient(90deg, var(--success-color), #00b87a)';
                } else if (item.status === 'failed') {
                    progressInner.style.background = 'var(--error-color)';
                }
            }

            // Update stats
            const statsEl = el.querySelector('.dq-stats');
            if (statsEl) {
                const pending = Math.max(0, total - processed);
                const cleanupDeleted = item.cleanup_deleted || 0;
                statsEl.innerHTML = `
                    ${dl > 0 ? `<span class="dq-stat"><span class="dq-stat-dot downloaded"></span>${dl} downloaded</span>` : ''}
                    ${skip > 0 ? `<span class="dq-stat"><span class="dq-stat-dot skipped"></span>${skip} in library</span>` : ''}
                    ${fail > 0 ? `<span class="dq-stat"><span class="dq-stat-dot failed"></span>${fail} failed</span>` : ''}
                    ${cleanupDeleted > 0 ? `<span class="dq-stat"><span class="dq-stat-dot" style="background-color: var(--warning-color); box-shadow: 0 0 6px rgba(255, 180, 0, 0.5);"></span>${cleanupDeleted} removed</span>` : ''}
                    ${pending > 0 && item.status === 'in_progress' ? `<span class="dq-stat"><span class="dq-stat-dot pending"></span>${pending} remaining</span>` : ''}
                `;
            }

            // Handle track list and expand button
            let trackList = el.querySelector('.dq-track-list');
            let expandBtn = el.querySelector('.dq-expand-btn');
            const isExpanded = expandedItems.has(item.id);

            if (tracks.length > 0) {
                // Create expand button if it doesn't exist
                if (!expandBtn) {
                    const btnHtml = `<button class="dq-expand-btn" onclick="toggleTrackList('${item.id}')">▶ SHOW TRACKS (${tracks.length})</button>`;
                    el.insertAdjacentHTML('beforeend', btnHtml);
                    expandBtn = el.querySelector('.dq-expand-btn');
                }

                // Create track list if it doesn't exist
                if (!trackList) {
                    const listHtml = `<div class="dq-track-list" data-item-id="${item.id}"></div>`;
                    el.insertAdjacentHTML('beforeend', listHtml);
                    trackList = el.querySelector('.dq-track-list');
                }

                // Update expand button text
                expandBtn.textContent = isExpanded ? '▼ HIDE TRACKS' : `▶ SHOW TRACKS (${tracks.length})`;

                // Update track list class
                trackList.classList.toggle('open', isExpanded);

                // Update track list content if expanded
                if (isExpanded) {
                    const scrollPos = trackList.scrollTop;
                    trackList.innerHTML = tracks.map(t => `
                        <div class="dq-track-entry">
                            <span class="dq-track-status-icon" style="color: ${_trackStatusColor(t.status)}">${_statusIcon(t.status, 14)}</span>
                            <span class="dq-track-label">${_escHtml(t.artist)} — ${_escHtml(t.title)}</span>
                            <span class="dq-track-msg">${_escHtml(t.message)}</span>
                        </div>
                    `).join('');
                    trackList.scrollTop = scrollPos;
                }
            }
        }

        async function fetchDownloadQueueStatus() {
            try {
                const response = await fetch('/api/download_queue');
                const data = await response.json();
                if (data.status === 'success') {
                    // Clear existing queue and repopulate, include message for failed items
                    downloadQueue.length = 0;
                    data.queue.forEach(item => downloadQueue.push({ ...item, message: item.message || '' }));
                    updateDownloadQueueUI();
                } else {
                    console.error('Failed to fetch download queue:', data.message);
                }
            } catch (error) {
                console.error('Network error fetching download queue:', error);
            }
        }

        // Start polling the download queue when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            fetchDownloadQueueStatus(); // Initial fetch immediately
            downloadQueueInterval = setInterval(fetchDownloadQueueStatus, 3000); // Poll every 3 seconds
        });

        function showMessage(type, text) {
            // Disabled - notifications removed per user request
            console.log(`[${type}] ${text}`);
        }

        function applyTemporaryFeedbackStyle(buttonElement, status) {
            const iconElement = buttonElement.querySelector('.feedback-icon');
            if (!iconElement) return;

            const className = status === 'success' ? 'success-feedback' : 'error-feedback';
            iconElement.classList.add(className);

            setTimeout(() => {
                iconElement.classList.remove(className);
            }, 1000); // Remove the style after 1 second
        }

        async function updateArl() {
            const arl = document.getElementById('arlInput').value;
            const response = await fetch('/api/update_arl', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ arl: arl })
            });
            const data = await response.json();
            showMessage(data.status, data.message);
        }

        async function updateCron() {
            const hour = document.getElementById('cronHour').value;
            const minute = document.getElementById('cronMinute').value;
            const day = document.getElementById('cronDay').value;
            const timezone = document.getElementById('cronTimezone').value;
            // Build cron schedule: "MINUTE HOUR * * DAY"
            const schedule = `${minute} ${hour} * * ${day}`;
            const response = await fetch('/api/update_cron', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ schedule: schedule, timezone: timezone })
            });
            const data = await response.json();
            showMessage(data.status, data.message);
        }

        async function toggleCronDisable() {
            const disabled = document.getElementById('disableCron').checked;
            const response = await fetch('/api/toggle_cron', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ disabled: disabled })
            });
            const data = await response.json();
            showMessage(data.status, data.message);
        }

        let llmAbortController = null; // Global variable to store the abort controller

        async function discoverLlmPlaylist() {
            const playlistDiv = document.getElementById('llmPlaylist');
            const statusDiv = document.getElementById('llmStatus');
            const toggleBtn = document.getElementById('llmToggle');

            // Cancel any existing request
            if (llmAbortController) {
                llmAbortController.abort();
            }

            // Create new abort controller for this request
            llmAbortController = new AbortController();

            playlistDiv.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100px;"><div class="spinner" style="margin-right: 8px;"></div><span>Querying the LLM for recommendations... (this can take a while)</span><button id="cancelLlmBtn" style="margin-left: 15px; padding: 5px 10px; background-color: var(--error-color); color: white; border: none; border-radius: 4px; cursor: pointer;" onclick="cancelLlmQuery()">Cancel</button></div>';
            statusDiv.textContent = '';
            toggleBtn.style.display = 'none';

            try {
                const response = await fetch('/api/get_llm_playlist', {
                    signal: llmAbortController.signal
                });
                const data = await response.json();

                if (data.status === 'success' && data.recommendations.length > 0) {
                    playlistDiv.innerHTML = data.recommendations.map((song, index) => {
                        const caaReleaseMbid = song.caa_release_mbid || '';
                        const caaId = song.caa_id || '';
                        return `<div class="playlist-item">
                            <div class="album-art-container">
                                <img src="/assets/default-album.svg" alt="Album Art" class="album-art" 
                                     id="llm-album-art-${index}" 
                                     data-caa-release-mbid="${caaReleaseMbid}" 
                                     data-caa-id="${caaId}"
                                     data-artist="${song.artist.replace(/"/g, '&quot;')}" data-album="${song.album.replace(/"/g, '&quot;')}">
                                <div class="album-art-spinner"></div>
                            </div>
                            <div class="track-info">
                                <div class="track-title">${song.title}</div>
                                <div class="track-artist">${song.artist}</div>
                                <div class="track-album">${song.album}</div>
                            </div>
                            <div class="feedback-buttons">
                                <button class="feedback-btn play-btn" onclick="playTrackPreview('${song.artist.replace(/'/g, "\\'")}', '${song.title.replace(/'/g, "\\'")}', this)" title="Play preview">
                                    <svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="feedback-icon">
                                        <path d="M5 3L19 12L5 21V3Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                </button>
                                <button class="feedback-btn download-btn" onclick="downloadIndividualTrack('${song.artist.replace(/'/g, "\\'")}', '${song.title.replace(/'/g, "\\'")}', this, false, 'LLM')" title="Download track">
                                    <svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="feedback-icon"><path d="M17 17H17.01M17.4 14H18C18.9319 14 19.3978 14 19.7654 14.1522C20.2554 14.3552 20.6448 14.7446 20.8478 15.2346C21 15.6022 21 16.0681 21 17C21 17.9319 21 18.3978 20.8478 18.7654C20.6448 19.2554 20.2554 19.6448 19.7654 19.8478C19.3978 20 18.9319 20 18 20H6C5.06812 20 4.60218 20 4.23463 19.8478C3.74458 19.6448 3.35523 19.2554 3.15224 18.7654C3 18.3978 3 17.9319 3 17C3 16.0681 3 15.6022 3.15224 15.2346C3.35523 14.7446 3.74458 14.3552 4.23463 14.1522C4.60218 14 5.06812 14 6 14H6.6M12 15V4M12 15L9 12M12 15L15 12" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                                </button>
                                <button class="feedback-btn like-btn" onclick="submitListenBrainzFeedback(this, '${song.recording_mbid || 'null'}', 1)" title="Like this track on ListenBrainz">
                                    <svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="feedback-icon">
                                        <path fill-rule="evenodd" clip-rule="evenodd" d="M12 6.00019C10.2006 3.90317 7.19377 3.2551 4.93923 5.17534C2.68468 7.09558 2.36727 10.3061 4.13778 12.5772C5.60984 14.4654 10.0648 18.4479 11.5249 19.7369C11.6882 19.8811 11.7699 19.9532 11.8652 19.9815C11.9483 20.0062 12.0393 20.0062 12.1225 19.9815C12.2178 19.9532 12.2994 19.8811 12.4628 19.7369C13.9229 18.4479 18.3778 14.4654 19.8499 12.5772C21.6204 10.3061 21.3417 7.07538 19.0484 5.17534C16.7551 3.2753 13.7994 3.90317 12 6.00019Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                </button>
                                <button class="feedback-btn dislike-btn" onclick="submitListenBrainzFeedback(this, '${song.recording_mbid || 'null'}', -1)" title="Dislike this track on ListenBrainz">
                                    <svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="feedback-icon">
                                        <path d="M12 6.00011L14 8.00011L10 10.0001L13 13.0001M12 6.00011C10.2006 3.90309 7.19377 3.25515 4.93923 5.17539C2.68468 7.09563 2.36727 10.3062 4.13778 12.5772C5.60984 14.4655 10.0648 18.4479 11.5249 19.7369C11.6882 19.8811 11.7699 19.9532 11.8652 19.9816C11.9483 20.0063 12.0393 20.0063 12.1225 19.9816C12.2178 19.9532 12.2994 19.8811 12.4628 19.7369C13.9229 18.4479 18.3778 14.4655 19.8499 12.5772C21.6204 10.3062 21.3417 7.07543 19.0484 5.17539C16.7551 3.27535 13.7994 3.90309 12 6.00011Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                </button>
                            </div>
                        </div>`;
                    }).join('');
                    document.getElementById('llmButtons').innerHTML = '<button class="download-btn" id="llmDownloadBtn" onclick="downloadLlmPlaylist()">Download All</button><button onclick="discoverLlmPlaylist()">Get New Suggestions</button>';
                    statusDiv.textContent = `${data.recommendations.length} songs recommended by LLM.`;
                    toggleBtn.style.display = 'inline-block';
                    lazyLoadAlbumArts('llmPlaylist');
                } else {
                    playlistDiv.innerHTML = `<div class="playlist-item">${data.message}</div>`;
                    statusDiv.textContent = 'No recommendations found';
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    playlistDiv.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100px;"><span>LLM query cancelled</span></div>';
                    statusDiv.textContent = 'Query cancelled';
                } else {
                    playlistDiv.innerHTML = `<div class="playlist-item">Network error: ${error.message}</div>`;
                    statusDiv.textContent = 'Network error';
                }
            }
        }

        function cancelLlmQuery() {
            if (llmAbortController) {
                llmAbortController.abort();
                showMessage('info', 'LLM query cancelled');
            }
        }

        async function downloadLlmPlaylist() {
            showMessage('info', 'LLM playlist download started...');
            const response = await fetch('/api/trigger_llm_download', { method: 'POST' });
            const data = await response.json();
            showMessage(data.status, data.message);
        }

        async function discoverListenBrainzPlaylist() {
            await getListenBrainzPlaylist(true);
        }

        async function refetchListenBrainzPlaylist() {
            await getListenBrainzPlaylist(false);
        }

        async function getListenBrainzPlaylist(isDiscover = false) {
            const playlistDiv = document.getElementById('listenBrainzPlaylist');
            const statusDiv = document.getElementById('listenBrainzStatus');
            const toggleBtn = document.getElementById('listenBrainzToggle');
            playlistDiv.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100px;"><div class="spinner" style="margin-right: 8px;"></div><span>Loading...</span></div>';
            statusDiv.textContent = '';
            toggleBtn.style.display = 'none';
            try {
                const response = await fetch('/api/get_listenbrainz_playlist');
                const text = await response.text();
                let data;
                try {
                    data = JSON.parse(text);
                } catch (jsonError) {
                    playlistDiv.innerHTML = `<div class="playlist-item">Error: ${response.status} ${response.statusText}<br><pre>${text}</pre></div>`;
                    statusDiv.textContent = 'Error loading playlist';
                    showMessage('error', `API returned non-JSON response: ${response.status}`);
                    return;
                }
                if (data.status === 'success' && data.recommendations.length > 0) {
                    playlistDiv.innerHTML = data.recommendations.map((song, index) => {
                        const recordingMbid = song.recording_mbid || 'null';
                        const caaReleaseMbid = song.caa_release_mbid || '';
                        const caaId = song.caa_id || '';
                        
                        // Default album art, will be replaced by lazy loading
                        const albumArtSrc = '/assets/default-album.svg';

                        return `<div class="playlist-item">
                            <div class="album-art-container">
                                <img src="${albumArtSrc}" alt="Album Art" class="album-art" 
                                     id="lb-album-art-${index}" 
                                     data-caa-release-mbid="${caaReleaseMbid}" 
                                     data-caa-id="${caaId}"
                                     data-artist="${song.artist.replace(/"/g, '&quot;')}"
                                     data-album="${song.album.replace(/"/g, '&quot;')}">
                                <div class="album-art-spinner"></div>
                            </div>
                            <div class="track-info">
                                <div class="track-title">${song.title}</div>
                                <div class="track-artist">${song.artist}</div>
                                <div class="track-album">${song.album}</div>
                            </div>
                            <div class="feedback-buttons">
                                <button class="feedback-btn play-btn" onclick="playTrackPreview('${song.artist.replace(/'/g, "\\'")}', '${song.title.replace(/'/g, "\\'")}', this)" title="Play preview">
                                    <svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="feedback-icon">
                                        <path d="M5 3L19 12L5 21V3Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                </button>
                                <button class="feedback-btn download-btn" onclick="downloadIndividualTrack('${song.artist.replace(/'/g, "\\'")}', '${song.title.replace(/'/g, "\\'")}', this, true, 'ListenBrainz')" title="Download track">
                                    <svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="feedback-icon">
                                        <path d="M17 17H17.01M17.4 14H18C18.9319 14 19.3978 14 19.7654 14.1522C20.2554 14.3552 20.6448 14.7446 20.8478 15.2346C21 15.6022 21 16.0681 21 17C21 17.9319 21 18.3978 20.8478 18.7654C20.6448 19.2554 20.2554 19.6448 19.7654 19.8478C19.3978 20 18.9319 20 18 20H6C5.06812 20 4.60218 20 4.23463 19.8478C3.74458 19.6448 3.35523 19.2554 3.15224 18.7654C3 18.3978 3 17.9319 3 17C3 16.0681 3 15.6022 3.15224 15.2346C3.35523 14.7446 3.74458 14.3552 4.23463 14.1522C4.60218 14 5.06812 14 6 14H6.6M12 15V4M12 15L9 12M12 15L15 12" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>                                    </svg>
                                </button>
                                <button class="feedback-btn like-btn" onclick="submitListenBrainzFeedback(this, '${recordingMbid}', 1)" title="Like this track">
                                    <svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="feedback-icon">
                                        <path fill-rule="evenodd" clip-rule="evenodd" d="M12 6.00019C10.2006 3.90317 7.19377 3.2551 4.93923 5.17534C2.68468 7.09558 2.36727 10.3061 4.13778 12.5772C5.60984 14.4654 10.0648 18.4479 11.5249 19.7369C11.6882 19.8811 11.7699 19.9532 11.8652 19.9815C11.9483 20.0062 12.0393 20.0062 12.1225 19.9815C12.2178 19.9532 12.2994 19.8811 12.4628 19.7369C13.9229 18.4479 18.3778 14.4654 19.8499 12.5772C21.6204 10.3061 21.3417 7.07538 19.0484 5.17534C16.7551 3.2753 13.7994 3.90317 12 6.00019Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                </button>
                                <button class="feedback-btn dislike-btn" onclick="submitListenBrainzFeedback(this, '${recordingMbid}', -1)" title="Dislike this track">
                                    <svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="feedback-icon">
                                        <path d="M12 6.00011L14 8.00011L10 10.0001L13 13.0001M12 6.00011C10.2006 3.90309 7.19377 3.25515 4.93923 5.17539C2.68468 7.09563 2.36727 10.3062 4.13778 12.5772C5.60984 14.4655 10.0648 18.4479 11.5249 19.7369C11.6882 19.8811 11.7699 19.9532 11.8652 19.9816C11.9483 20.0063 12.0393 20.0063 12.1225 19.9816C12.2178 19.9532 12.2994 19.8811 12.4628 19.7369C13.9229 18.4479 18.3778 14.4655 19.8499 12.5772C21.6204 10.3062 21.3417 7.07543 19.0484 5.17539C16.7551 3.27535 13.7994 3.90309 12 6.00011Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                </button>
                            </div>
                        </div>`;
                    }).join('');
                    if (isDiscover) {
                        document.getElementById('listenBrainzButtons').innerHTML = '<button class="download-btn" id="listenBrainzDownloadBtn" onclick="downloadListenBrainzPlaylist()">Download all</button><button onclick="refetchListenBrainzPlaylist()">Refetch</button>';
                    }
                    // Setup intersection observer for lazy loading album art
                    statusDiv.textContent = `${data.recommendations.length} songs fetched from ListenBrainz`;
                    toggleBtn.style.display = 'inline-block';
                    showMessage('info', `Found ${data.recommendations.length} ListenBrainz recommendations.`);
                } else {
                    playlistDiv.innerHTML = `<div class="playlist-item">${data.message}</div>`;
                    statusDiv.textContent = 'No recommendations found';
                    showMessage(data.status, data.message);
                }
                // Call lazy load function for all album arts after rendering
                lazyLoadAlbumArts('listenBrainzPlaylist');
            } catch (error) {
                playlistDiv.innerHTML = `<div class="playlist-item">Network error: ${error.message}</div>`;
                statusDiv.textContent = 'Network error';
                showMessage('error', `Network error: ${error.message}`);
            }
        }

        async function downloadListenBrainzPlaylistDirect() {
            const response = await fetch('/api/trigger_listenbrainz_download', {
                method: 'POST'
            });
            const data = await response.json();
            showMessage(data.status, data.message);
        }

        async function downloadListenBrainzPlaylist() {
            const downloadBtn = document.getElementById('listenBrainzDownloadBtn');
            downloadBtn.innerHTML = '<div class="spinner" style="margin-right: 8px;"></div>Downloading...';
            downloadBtn.disabled = true;

            // Show immediate feedback message
            showMessage('info', 'Download started...');
            // Add to client-side queue display immediately
            const downloadId = `listenbrainz-${Date.now()}`;
            downloadQueue.unshift({ id: downloadId, artist: 'ListenBrainz Playlist', title: 'Multiple Tracks', status: 'in_progress' });
            updateDownloadQueueUI();

            const response = await fetch('/api/trigger_listenbrainz_download', {
                method: 'POST'
            });
            const data = await response.json();
            // The polling function will update the actual status
            setTimeout(() => {
                downloadBtn.innerHTML = 'Download all';
                downloadBtn.disabled = false;
                showMessage(data.status, data.message);
            }, 2000);
        }

        async function discoverLastFmPlaylist() {
            await getLastFmPlaylist(true);
        }

        async function refetchLastFmPlaylist() {
            await getLastFmPlaylist(false);
        }

        async function getLastFmPlaylist(isDiscover = false) {
            const playlistDiv = document.getElementById('lastFmPlaylist');
            const statusDiv = document.getElementById('lastFmStatus');
            const toggleBtn = document.getElementById('lastFmToggle');
            playlistDiv.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100px;"><div class="spinner" style="margin-right: 8px;"></div><span>Loading...</span></div>';
            statusDiv.textContent = '';
            toggleBtn.style.display = 'none';
            try {
                const response = await fetch('/api/get_lastfm_playlist');
                const data = await response.json();
                if (data.status === 'success' && data.recommendations.length > 0) {
                    playlistDiv.innerHTML = data.recommendations.map((song, index) => {
                        const albumArtSrc = song.album_art || '/assets/default-album.svg';
                        const albumArtLoadedClass = song.album_art ? 'loaded' : ''; // Add 'loaded' class if art is pre-fetched
                        const spinnerDisplay = song.album_art ? 'none' : 'block'; // Hide spinner if art is pre-fetched

                        return `<div class="playlist-item">
                            <div class="album-art-container">
                                <img src="${albumArtSrc}" alt="Album Art" class="album-art ${albumArtLoadedClass}" id="lf-album-art-${index}" data-artist="${song.artist.replace(/"/g, '&quot;')}" data-album="${song.album.replace(/"/g, '&quot;')}" data-title="${song.title.replace(/"/g, '&quot;')}">
                                <div class="album-art-spinner" style="display: ${spinnerDisplay};"></div>
                            </div>
                            <div class="track-info">
                                <div class="track-title">${song.title}</div>
                                <div class="track-artist">${song.artist}</div>
                                <div class="track-album">${song.album}</div>
                            </div>
                            <div class="feedback-buttons">
                                <button class="feedback-btn play-btn" onclick="playTrackPreview('${song.artist.replace(/'/g, "\\'")}', '${song.title.replace(/'/g, "\\'")}', this)" title="Play preview">
                                    <svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="feedback-icon">
                                        <path d="M5 3L19 12L5 21V3Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                </button>
                                <button class="feedback-btn download-btn" onclick="downloadIndividualTrack('${song.artist.replace(/'/g, "\\'")}', '${song.title.replace(/'/g, "\\'")}', this, false, 'Last.fm')" title="Download track">
                                    <svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="feedback-icon">
                                        <path d="M17 17H17.01M17.4 14H18C18.9319 14 19.3978 14 19.7654 14.1522C20.2554 14.3552 20.6448 14.7446 20.8478 15.2346C21 15.6022 21 16.0681 21 17C21 17.9319 21 18.3978 20.8478 19.8478C20.6448 19.2554 20.2554 19.6448 19.7654 19.8478C19.3978 20 18.9319 20 18 20H6C5.06812 20 4.60218 20 4.23463 19.8478C3.74458 19.6448 3.35523 19.2554 3.15224 19.2346C3 18.6022 3 18.0681 3 17C3 16.0681 3 15.6022 3.15224 15.2346C3.35523 14.7446 3.74458 14.3552 4.23463 14.1522C4.60218 14 5.06812 14 6 14H6.6M12 15V4M12 15L9 12M12 15L15 12" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>                                    </svg>
                                </button>
                            </div>
                        </div>`;
                    }).join('');
                    // No need to call loadAlbumArt for each song, as it's pre-populated in the backend
                    if (isDiscover) {
                        document.getElementById('lastFmButtons').innerHTML = '<button class="download-btn" id="lastFmDownloadBtn" onclick="downloadLastFmPlaylist()">Download all</button><button onclick="refetchLastFmPlaylist()">Refetch</button>';
                    }
                    statusDiv.textContent = `${data.recommendations.length} songs fetched from Last.fm`;
                    toggleBtn.style.display = 'inline-block';
                    showMessage('info', `Found ${data.recommendations.length} Last.fm recommendations.`);
                } else {
                    playlistDiv.innerHTML = `<div class="playlist-item">${data.message}</div>`;
                    statusDiv.textContent = 'No recommendations found';
                    showMessage(data.status, data.message);
                }
            } catch (error) {
                playlistDiv.innerHTML = `<div class="playlist-item">Network error: ${error.message}</div>`;
                statusDiv.textContent = 'Network error';
                showMessage('error', `Network error: ${error.message}`);
            }
        }

        async function downloadLastFmPlaylistDirect() {
            const response = await fetch('/api/trigger_lastfm_download', {
                method: 'POST'
            });
            const data = await response.json();
            showMessage(data.status, data.message);
        }

        async function downloadLastFmPlaylist() {
            const downloadBtn = document.getElementById('lastFmDownloadBtn');
            downloadBtn.innerHTML = '<div class="spinner" style="margin-right: 8px;"></div>Downloading...';
            downloadBtn.disabled = true;

            // Show immediate feedback message
            showMessage('info', 'Download started...');
            // Add to client-side queue display immediately
            const downloadId = `lastfm-${Date.now()}`;
            downloadQueue.unshift({ id: downloadId, artist: 'Last.fm Playlist', title: 'Multiple Tracks', status: 'in_progress' });
            updateDownloadQueueUI();

            const response = await fetch('/api/trigger_lastfm_download', {
                method: 'POST'
            });
            const data = await response.json();
            // The polling function will update the actual status
            setTimeout(() => {
                downloadBtn.innerHTML = 'Download';
                downloadBtn.disabled = false;
                showMessage(data.status, data.message);
            }, 2000);
        }

        async function submitListenBrainzFeedback(buttonElement, recording_mbid, score) {
            // Frontend validation for MBID
            if (!recording_mbid || recording_mbid === 'null') {
                showMessage('error', 'Cannot submit feedback: MusicBrainz ID is missing for this track.');
                applyTemporaryFeedbackStyle(buttonElement, 'error');
                return;
            }

            try {
                const response = await fetch('/api/submit_listenbrainz_feedback', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ recording_mbid: recording_mbid, score: score })
                });
                const data = await response.json();
                showMessage(data.status, data.message);
                applyTemporaryFeedbackStyle(buttonElement, data.status);
            } catch (error) {
                console.error('Error submitting feedback:', error);
                showMessage('error', 'Failed to submit feedback');
                applyTemporaryFeedbackStyle(buttonElement, 'error'); // Apply error style on network error
            }
        }

        async function downloadFreshRelease(artist, album, releaseDate) {
            // Get the state of the album recommendation setting from config
            const isAlbumRecommendation = window.albumRecommendationEnabled || false;

            // Show immediate feedback message
            showMessage('info', 'Download started...');
            // Add to client-side queue display immediately
            downloadQueue.unshift({ artist: artist, title: album, status: 'in_progress' });
            updateDownloadQueueUI();

            const response = await fetch('/api/trigger_fresh_release_download', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    artist: artist,
                    album: album,
                    release_date: releaseDate,
                    is_album_recommendation: isAlbumRecommendation
                })
            });
            const data = await response.json();
            showMessage(data.status, data.message);
            // The polling function will update the actual status
        }

        let currentAudio = null; // Global variable to keep track of currently playing audio

        async function playTrackPreview(artist, title, buttonElement) {
            try {
                // If clicking the same button that's already playing, stop the audio
                if (buttonElement.classList.contains('playing') && currentAudio) {
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                    currentAudio = null;
                    buttonElement.classList.remove('playing');
                    const icon = buttonElement.querySelector('.feedback-icon path');
                    if (icon) {
                        icon.setAttribute('d', 'M5 3L19 12L5 21V3Z'); // Play icon
                    }
                    return;
                }

                // Stop any currently playing audio
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                    // Reset previous play button icon
                    const prevPlayBtn = document.querySelector('.play-btn.playing');
                    if (prevPlayBtn) {
                        prevPlayBtn.classList.remove('playing');
                        const prevIcon = prevPlayBtn.querySelector('.feedback-icon path');
                        if (prevIcon) {
                            prevIcon.setAttribute('d', 'M5 3L19 12L5 21V3Z'); // Play icon
                        }
                    }
                }

                // Fetch preview URL
                const response = await fetch(`/api/get_track_preview?artist=${encodeURIComponent(artist)}&title=${encodeURIComponent(title)}`);
                const data = await response.json();

                if (data.status === 'success' && data.preview_url) {
                    // Create new audio element
                    currentAudio = new Audio(data.preview_url);
                    
                    // Update button to show pause icon
                    buttonElement.classList.add('playing');
                    const icon = buttonElement.querySelector('.feedback-icon path');
                    if (icon) {
                        icon.setAttribute('d', 'M6 4H18V20H6V4Z'); // Pause icon
                    }

                    // Handle audio end
                    currentAudio.addEventListener('ended', () => {
                        buttonElement.classList.remove('playing');
                        const icon = buttonElement.querySelector('.feedback-icon path');
                        if (icon) {
                            icon.setAttribute('d', 'M5 3L19 12L5 21V3Z'); // Play icon
                        }
                        currentAudio = null;
                    });

                    // Handle errors
                    currentAudio.addEventListener('error', () => {
                        showMessage('error', 'Failed to play preview');
                        buttonElement.classList.remove('playing');
                        const icon = buttonElement.querySelector('.feedback-icon path');
                        if (icon) {
                            icon.setAttribute('d', 'M5 3L19 12L5 21V3Z'); // Play icon
                        }
                        currentAudio = null;
                    });

                    // Play the audio
                    await currentAudio.play();
                } else {
                    showMessage('error', data.message || 'Preview not available for this track');
                }
            } catch (error) {
                console.error('Error playing preview:', error);
                showMessage('error', 'Failed to play preview');
            }
        }

        async function downloadIndividualTrack(artist, title, buttonElement, lb_recommendation = false, source = 'Manual') {
            try {
                // Update button to show loading state
                const originalContent = buttonElement.innerHTML;
                buttonElement.innerHTML = '<div class="spinner"></div>';
                buttonElement.disabled = true;

                // Show immediate feedback message
                showMessage('info', 'Download started...');
                // Add to client-side queue display immediately
                downloadQueue.unshift({ artist: artist, title: title, status: 'in_progress' });
                updateDownloadQueueUI();

                const response = await fetch('/api/trigger_track_download', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ artist: artist, title: title, lb_recommendation: lb_recommendation, source: source })
                });
                const data = await response.json();
                showMessage(data.status, data.message);

                // Reset button after a delay
                setTimeout(() => {
                    buttonElement.innerHTML = originalContent;
                    buttonElement.disabled = false;
                }, 2000);
            } catch (error) {
                console.error('Error downloading track:', error);
                showMessage('error', 'Failed to download track');
                // Reset button on error
                buttonElement.innerHTML = originalContent;
                buttonElement.disabled = false;
            }
        }

        async function fetchFreshReleases() {
            const playlistDiv = document.getElementById('freshReleasesPlaylist');
            playlistDiv.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100px;"><div class="spinner" style="margin-right: 8px;"></div><span>Loading...</span></div>';
            try {
                const response = await fetch('/api/get_fresh_releases');
                const text = await response.text();
                let data;
                try {
                    data = JSON.parse(text);
                } catch (jsonError) {
                    playlistDiv.innerHTML = `<div class="playlist-item">Error: ${response.status} ${response.statusText}<br><pre>${text}</pre></div>`;
                    showMessage('error', `API returned non-JSON response for fresh releases: ${response.status}`);
                    return;
                }

                if (data.status === 'success' && data.releases.length > 0) {
                    playlistDiv.innerHTML = `
                        <div class="carousel-container">
                            <button class="carousel-btn prev-btn" onclick="scrollCarousel('freshReleases', -1)"><</button>
                            <div class="carousel" id="freshReleasesCarousel">
                                ${data.releases.map((release, index) => {
                                    const caaReleaseMbid = release.caa_release_mbid || release.release_mbid || '';
                                    const caaId = release.caa_id || '';
                                    return `<div class="release-item">
                                        <div class="release-art-container">
                                            <img src="/assets/default-album.svg" alt="Album Art" class="release-art"
                                                 id="fr-album-art-${index}"
                                                 data-caa-release-mbid="${caaReleaseMbid}"
                                                 data-caa-id="${caaId}"
                                                 data-artist="${release.artist_credit_name.replace(/"/g, '&quot;')}"
                                                 data-album="${release.release_name.replace(/"/g, '&quot;')}">
                                            <div class="release-art-spinner"></div>
                                        </div>
                                        <div class="release-info">
                                            <div class="release-artist">${release.artist_credit_name}</div>
                                            <div class="release-album">${release.release_name}</div>
                                            <div class="release-date">${release.release_date}</div>
                                            ${release.is_available_on_deezer ? 
                                                `<button class="release-download-btn" onclick="downloadFreshRelease('${release.artist_credit_name.replace(/'/g, "\\'")}', '${release.release_name.replace(/'/g, "\\'")}', '${release.release_date || ''}')">Download</button>` : 
                                                `<button class="release-download-btn" disabled title="Not available on Deezer">Not Available</button>`
                                            }
                                        </div>
                                    </div>`;
                                }).join('')}
                            </div>
                            <button class="carousel-btn next-btn" onclick="scrollCarousel('freshReleases', 1)">></button>
                        </div>
                    `;
                    // Call lazy load function for all album arts after rendering
                    lazyLoadAlbumArts('freshReleasesPlaylist');
                } else {
                    playlistDiv.innerHTML = `<div class="playlist-item">${data.message}</div>`;
                    showMessage(data.status, data.message);
                }
            } catch (error) {
                playlistDiv.innerHTML = `<div class="playlist-item">Network error: ${error.message}</div>`;
                showMessage('error', `Network error fetching fresh releases: ${error.message}`);
            }
        }

        function scrollCarousel(service, direction) {
            const carousel = document.getElementById(`${service}Carousel`);
            const scrollAmount = 220;
            const currentScroll = carousel.scrollLeft;
            const newScroll = currentScroll + (direction * scrollAmount);
            carousel.scrollTo({
                left: newScroll,
                behavior: 'smooth'
            });
        }

        // Lazy loading function
        function lazyLoadAlbumArts(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const images = container.querySelectorAll('.album-art, .release-art');
            const imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        const caaReleaseMbid = img.dataset.caaReleaseMbid;
                        const caaId = img.dataset.caaId;

                        let imageUrl = '/assets/default-album.svg';

                        if (caaReleaseMbid && caaId) {
                            imageUrl = `http://coverartarchive.org/release/${caaReleaseMbid}/${caaId}-250.jpg`;
                        } else if (caaReleaseMbid) {
                            imageUrl = `https://coverartarchive.org/release/${caaReleaseMbid}/front-250.jpg`; // Simple fallback
                        }

                        const spinner = img.nextElementSibling;
                        if (spinner) spinner.style.display = 'block';
                        img.style.opacity = '0'; // Hide image initially

                        img.src = imageUrl;
                        img.onload = () => {
                            img.classList.add('loaded');
                            img.style.opacity = '1';
                            if (spinner) spinner.style.display = 'none';
                        };
                        img.onerror = async () => {
                            const artist = img.dataset.artist;
                            const album = img.dataset.album;

                            if (artist && album) {
                                try {
                                    const deezerResponse = await fetch(`/api/get_deezer_album_art?artist=${encodeURIComponent(artist)}&album_title=${encodeURIComponent(album)}`);
                                    const deezerData = await deezerResponse.json();
                                    if (deezerData.status === 'success' && deezerData.album_art_url) {
                                        img.src = deezerData.album_art_url;
                                        img.onload = () => {
                                            img.classList.add('loaded');
                                            img.style.opacity = '1';
                                            if (spinner) spinner.style.display = 'none';
                                        };
                                        img.onerror = () => { // Fallback if Deezer image also fails
                                            img.src = '/assets/default-album.svg';
                                            img.classList.add('loaded');
                                            img.style.opacity = '1';
                                            if (spinner) spinner.style.display = 'none';
                                        };
                                    } else {
                                        img.src = '/assets/default-album.svg';
                                        img.classList.add('loaded');
                                        img.style.opacity = '1';
                                        if (spinner) spinner.style.display = 'none';
                                    }
                                } catch (deezerError) {
                                    console.error('Error fetching Deezer album art:', deezerError);
                                    img.src = '/assets/default-album.svg';
                                    img.classList.add('loaded');
                                    img.style.opacity = '1';
                                    if (spinner) spinner.style.display = 'none';
                                }
                            } else {
                                img.src = '/assets/default-album.svg';
                                img.classList.add('loaded');
                                img.style.opacity = '1';
                                if (spinner) spinner.style.display = 'none';
                            }
                        };
                        observer.unobserve(img);
                    }
                });
            }, {
                rootMargin: '0px',
                threshold: 0.1
            });

            images.forEach(img => imageObserver.observe(img));
        }

        async function loadConfiguration() {
            // Use cached config if available for instant loading
            let config = window.cachedConfig;

            if (config) {
                // Populate form fields immediately from cache
                populateConfigFields(config);
            }

            // Fetch latest config in background
            try {
                const response = await fetch('/api/config');
                const freshConfig = await response.json();

                // Update cache
                window.cachedConfig = freshConfig;

                // If config changed or no cache was used, update fields
                if (!config || JSON.stringify(config) !== JSON.stringify(freshConfig)) {
                    populateConfigFields(freshConfig);
                }
            } catch (error) {
                console.error('Error loading configuration:', error);
                if (!config) {
                    showMessage('error', 'Failed to load configuration');
                }
            }
        }

        function populateConfigFields(config) {
            // Populate automation fields only (services are now per-user)
            document.getElementById('albumRecommendationEnabled').checked = config.ALBUM_RECOMMENDATION_ENABLED || false;

            // Set global variable for album recommendation setting
            window.albumRecommendationEnabled = config.ALBUM_RECOMMENDATION_ENABLED || false;

            // Update UI visibility based on configuration
            updateUIVisibility(config);
        }

        function updateUIVisibility(config) {
            // Check if configuration is empty (no services configured)
            const hasNavidrome = (config.ROOT_ND && config.ROOT_ND !== '') || (config.USER_ND && config.USER_ND !== '') || (config.PASSWORD_ND && config.PASSWORD_ND !== '');
            const hasListenBrainz = config.LISTENBRAINZ_ENABLED && ((config.TOKEN_LB && config.TOKEN_LB !== '') || (config.USER_LB && config.USER_LB !== ''));
            const hasLastFm = config.LASTFM_ENABLED;
            const hasAnyConfig = hasNavidrome || hasListenBrainz || hasLastFm || (config.DEEZER_ARL && config.DEEZER_ARL !== '');
            const llmSection = document.getElementById('llmSection');

            // Welcome message is hidden by default - user can click ? button to show it
            // We don't auto-show it since logged-in users already have a working Navidrome setup

            // Show/hide sections based on enabled services and hide options
            const freshReleasesSection = document.getElementById('freshReleasesSection');
            const listenBrainzSection = document.getElementById('listenBrainzSection');
            const lastFmSection = document.getElementById('lastFmSection');
            const llmHeaderContent = document.getElementById('llmHeaderContent');

            // ListenBrainz section is shown if enabled, independent of fresh releases
            if (config.LISTENBRAINZ_ENABLED) {
                listenBrainzSection.style.display = 'block';
            } else {
                listenBrainzSection.style.display = 'none';
            }

            // Fresh releases are part of ListenBrainz, but can be hidden independently
            if (config.LISTENBRAINZ_ENABLED && !config.HIDE_FRESH_RELEASES) {
                freshReleasesSection.style.display = 'block';
            } else {
                freshReleasesSection.style.display = 'none';
            }

            if (config.LASTFM_ENABLED) {
                lastFmSection.style.display = 'block';
            } else {
                lastFmSection.style.display = 'none';
            }

            if (config.LLM_ENABLED) {
                llmSection.style.display = 'block';
                if (config.LLM_PROVIDER === 'gemini') {
                    llmHeaderContent.innerHTML = '<img src="/assets/gemini_logo.svg" alt="Gemini" class="logo service-logo"><h2></h2>';
                } else if (config.LLM_PROVIDER === 'openrouter') {
                    llmHeaderContent.innerHTML = '<img src="/assets/openrouter_logo.svg" alt="OpenRouter" class="logo service-logo"><h2></h2>';
                } else {
                    llmHeaderContent.innerHTML = '<h2>LLM Suggestions</h2>';
                }
            } else {
                llmSection.style.display = 'none';
            }

            // Show/hide downloadFromLinkSection based on configuration and hide option
            const downloadFromLinkSection = document.getElementById('downloadFromLinkSection');
            if (hasAnyConfig && !config.HIDE_DOWNLOAD_FROM_LINK) {
                downloadFromLinkSection.style.display = 'block';
            } else {
                downloadFromLinkSection.style.display = 'none';
            }

            // Show "Run Now" button if any recommendation source is enabled
            const runNowSection = document.getElementById('runNowSection');
            if (hasListenBrainz || hasLastFm || config.LLM_ENABLED) {
                runNowSection.style.display = 'block';
            } else {
                runNowSection.style.display = 'none';
            }
        }

        async function saveAutomationOptions() {
            const hour = document.getElementById('cronHour').value;
            const minute = document.getElementById('cronMinute').value;
            const day = document.getElementById('cronDay').value;
            const disabled = document.getElementById('disableCron').checked;
            const timezone = document.getElementById('cronTimezone').value;

            // Build cron schedule: "MINUTE HOUR * * DAY"
            const schedule = `${minute} ${hour} * * ${day}`;

            try {
                // Update cron schedule
                const cronResponse = await fetch('/api/update_cron', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ schedule: schedule, timezone: timezone })
                });
                const cronData = await cronResponse.json();

                // Update cron disable state
                const disableResponse = await fetch('/api/toggle_cron', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ disabled: disabled })
                });
                const disableData = await disableResponse.json();

                // Show success message if all operations succeeded
                if (cronData.status === 'success' && disableData.status === 'success') {
                    showMessage('success', 'Automation options saved successfully.');
                    setTimeout(() => {
                        location.reload();
                    }, 1000);
                } else {
                    const errors = [];
                    if (cronData.status !== 'success') errors.push(`Cron: ${cronData.message}`);
                    if (disableData.status !== 'success') errors.push(`Disable: ${disableData.message}`);
                    showMessage('error', `Failed to save some automation options: ${errors.join(', ')}`);
                }
            } catch (error) {
                console.error('Error saving automation options:', error);
                showMessage('error', 'Failed to save automation options');
            }
        }

        async function runNow() {
            const btn = document.getElementById('runNowBtnSettings');
            const originalText = btn ? btn.textContent : '';
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Fetching...';
            }
            try {
                const response = await fetch('/api/run_now', { method: 'POST' });
                const data = await response.json();
                showMessage(data.status, data.message);
                openDownloadQueueModal();
            } catch (error) {
                console.error('Error running now:', error);
                showMessage('error', 'Failed to start recommendation fetch');
            }
            if (btn) {
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }

        // Detect playlist URLs client-side for immediate UI feedback
        function _isPlaylistUrl(url) {
            return /deezer\.com(?:\/[a-z]{2})?\/playlist\/\d+/.test(url) ||
                   /link\.deezer\.com\/s\/[a-zA-Z0-9]+/.test(url) ||
                   /open\.spotify\.com\/playlist\/[a-zA-Z0-9]+/.test(url) ||
                   /(?:listen\.)?tidal\.com\/(?:browse\/)?playlist\/[0-9a-zA-Z-]+/.test(url) ||
                   /(?:music\.)?youtube\.com\/playlist\?list=[a-zA-Z0-9_-]+/.test(url);
        }

        // --- Playlist mode popup state ---
        let _pendingPlaylistLink = '';
        let _playlistPopupState = {
            originalName: '',
            trackCount: 0,
            nameExists: false,
            nameIsMonitored: false,
            urlIsMonitored: false,
            monitoredId: null,
        };
        let _nameCheckTimeout = null;

        async function _showPlaylistPopup(url) {
            _pendingPlaylistLink = url;

            // Reset UI state
            const nameInput = document.getElementById('playlistNameInput');
            const urlEl = document.getElementById('playlistModeUrl');
            const trackCountEl = document.getElementById('playlistModeTrackCount');
            const statusMsg = document.getElementById('playlistStatusMessage');
            const monitorToggle = document.getElementById('playlistMonitorToggle');
            const monitorOptions = document.getElementById('playlistMonitorOptions');
            const downloadBtn = document.getElementById('playlistDownloadBtn');

            nameInput.value = '';
            urlEl.textContent = url;
            trackCountEl.textContent = '';
            statusMsg.style.display = 'none';
            monitorToggle.checked = false;
            monitorToggle.disabled = false;
            monitorOptions.style.display = 'none';
            downloadBtn.disabled = false;
            downloadBtn.textContent = 'Download';

            // Call preflight to get playlist info
            try {
                const resp = await fetch('/api/playlist_preflight', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url })
                });
                const result = await resp.json();
                if (result.status === 'success') {
                    _playlistPopupState = {
                        originalName: result.name,
                        trackCount: result.track_count,
                        nameExists: result.exists,
                        nameIsMonitored: false, // Will check via name check
                        urlIsMonitored: result.is_monitored,
                        monitoredId: result.monitored_id,
                    };

                    nameInput.value = result.name;
                    trackCountEl.textContent = `${result.track_count} tracks`;

                    // If URL is already monitored, show special message
                    if (result.is_monitored) {
                        statusMsg.textContent = `This playlist is already being monitored as "${result.monitored_name}". Downloading will sync new tracks.`;
                        statusMsg.style.display = 'block';
                        statusMsg.style.background = 'rgba(100,170,255,0.1)';
                        statusMsg.style.border = '1px solid rgba(100,170,255,0.3)';
                        statusMsg.style.color = '#8ac4ff';
                        monitorToggle.checked = true;
                        monitorToggle.disabled = true; // Can't unmonitor from here
                        monitorOptions.style.display = 'block';
                        downloadBtn.textContent = 'Sync Playlist';
                    } else {
                        // Check name status
                        await _checkPlaylistName(result.name);
                    }
                } else {
                    statusMsg.textContent = result.message || 'Error loading playlist info';
                    statusMsg.style.display = 'block';
                    statusMsg.style.background = 'rgba(255,100,100,0.1)';
                    statusMsg.style.border = '1px solid rgba(255,100,100,0.3)';
                    statusMsg.style.color = '#ff8080';
                }
            } catch (e) {
                console.error('Preflight error:', e);
            }

            document.getElementById('playlistModeOverlay').classList.add('open');
        }

        async function _checkPlaylistName(name) {
            const statusMsg = document.getElementById('playlistStatusMessage');
            const downloadBtn = document.getElementById('playlistDownloadBtn');
            const monitorToggle = document.getElementById('playlistMonitorToggle');

            if (!name || !name.trim()) {
                statusMsg.style.display = 'none';
                downloadBtn.disabled = true;
                downloadBtn.textContent = 'Download';
                return;
            }

            try {
                const resp = await fetch('/api/playlist_check_name', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: name.trim() })
                });
                const result = await resp.json();

                _playlistPopupState.nameExists = result.exists;
                _playlistPopupState.nameIsMonitored = result.is_monitored;

                if (result.exists) {
                    if (result.is_monitored) {
                        // Name exists and is monitored - can't overwrite
                        statusMsg.textContent = 'This playlist name is already being monitored. Choose a different name.';
                        statusMsg.style.display = 'block';
                        statusMsg.style.background = 'rgba(255,100,100,0.1)';
                        statusMsg.style.border = '1px solid rgba(255,100,100,0.3)';
                        statusMsg.style.color = '#ff8080';
                        downloadBtn.disabled = true;
                        downloadBtn.textContent = 'Cannot Overwrite Monitored Playlist';
                    } else {
                        // Name exists but not monitored - can overwrite
                        statusMsg.textContent = 'A playlist with this name exists. It will be overwritten.';
                        statusMsg.style.display = 'block';
                        statusMsg.style.background = 'rgba(255,170,0,0.1)';
                        statusMsg.style.border = '1px solid rgba(255,170,0,0.3)';
                        statusMsg.style.color = '#ffa600';
                        downloadBtn.disabled = false;
                        downloadBtn.textContent = monitorToggle.checked ? 'Overwrite & Monitor' : 'Overwrite Playlist';
                    }
                } else {
                    // Name doesn't exist - create new
                    statusMsg.style.display = 'none';
                    downloadBtn.disabled = false;
                    downloadBtn.textContent = monitorToggle.checked ? 'Download & Monitor' : 'Download';
                }
            } catch (e) {
                console.error('Name check error:', e);
            }
        }

        function _updatePlaylistButtonText() {
            const downloadBtn = document.getElementById('playlistDownloadBtn');
            const monitorToggle = document.getElementById('playlistMonitorToggle');

            if (_playlistPopupState.urlIsMonitored) {
                downloadBtn.textContent = 'Sync Playlist';
                return;
            }

            if (_playlistPopupState.nameIsMonitored) {
                downloadBtn.disabled = true;
                downloadBtn.textContent = 'Cannot Overwrite Monitored Playlist';
                return;
            }

            downloadBtn.disabled = false;
            if (_playlistPopupState.nameExists) {
                downloadBtn.textContent = monitorToggle.checked ? 'Overwrite & Monitor' : 'Overwrite Playlist';
            } else {
                downloadBtn.textContent = monitorToggle.checked ? 'Download & Monitor' : 'Download';
            }
        }

        function _hidePlaylistPopup() {
            document.getElementById('playlistModeOverlay').classList.remove('open');
            _pendingPlaylistLink = '';
            // Reset the download button in case popup was dismissed without submitting
            const downloadLinkBtn = document.getElementById('downloadLinkBtn');
            downloadLinkBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>';
            downloadLinkBtn.disabled = false;
        }

        // Close popup on overlay click
        document.getElementById('playlistModeOverlay').addEventListener('click', function(e) {
            if (e.target === this) _hidePlaylistPopup();
        });

        // Monitor toggle shows/hides options and updates button text
        document.getElementById('playlistMonitorToggle').addEventListener('change', function() {
            document.getElementById('playlistMonitorOptions').style.display = this.checked ? 'block' : 'none';
            _updatePlaylistButtonText();
        });

        // Debounced name check as user types
        document.getElementById('playlistNameInput').addEventListener('input', function() {
            clearTimeout(_nameCheckTimeout);
            _nameCheckTimeout = setTimeout(() => {
                if (!_playlistPopupState.urlIsMonitored) {
                    _checkPlaylistName(this.value);
                }
            }, 300);
        });

        // Download button click handler
        document.getElementById('playlistDownloadBtn').addEventListener('click', async function() {
            const musicLink = _pendingPlaylistLink;
            if (!musicLink) return;

            const playlistName = document.getElementById('playlistNameInput').value.trim();
            if (!playlistName) {
                showMessage('error', 'Please enter a name for the playlist.');
                return;
            }

            const monitor = document.getElementById('playlistMonitorToggle').checked;
            const pollInterval = parseInt(document.getElementById('playlistPollInterval').value) || 24;
            const autoCleanup = document.getElementById('playlistAutoCleanup').checked;

            showMessage('info', monitor
                ? 'Playlist download started. It will be monitored for new tracks.'
                : 'Playlist download started. Check the download queue for progress.');
            openDownloadQueueModal();

            _hidePlaylistPopup();

            try {
                const body = {
                    link: musicLink,
                    monitor,
                    poll_interval_hours: pollInterval,
                    auto_cleanup: autoCleanup,
                    playlist_name: playlistName !== _playlistPopupState.originalName ? playlistName : null
                };
                const response = await fetch('/api/download_from_link', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                const data = await response.json();
                if (data.status === 'success') {
                    document.getElementById('musicLinkInput').value = '';
                    if (monitor) loadMonitoredPlaylists();
                }
            } catch (error) {
                console.error('Error downloading playlist:', error);
                showMessage('error', 'Failed to initiate playlist download.');
            }

            const downloadLinkBtn = document.getElementById('downloadLinkBtn');
            setTimeout(() => {
                downloadLinkBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>';
                downloadLinkBtn.disabled = false;
            }, 500);
        });

        // Helper to reset download button
        function _resetDownloadBtn(downloadLinkBtn) {
            downloadLinkBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>';
            downloadLinkBtn.disabled = false;
        }

        // Actually perform the playlist download
        async function _doPlaylistDownload(url, playlistName, downloadLinkBtn) {
            try {
                downloadLinkBtn.innerHTML = '<div class="spinner"></div>Downloading...';
                showMessage('info', `Downloading playlist: ${playlistName}`);
                downloadQueue.unshift({ artist: 'Playlist', title: playlistName, status: 'in_progress' });
                updateDownloadQueueUI();
                openDownloadQueueModal();

                const response = await fetch('/api/download_from_link', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        link: url,
                        monitor: false,
                        playlist_name: null
                    })
                });
                const data = await response.json();
                showMessage(data.status, data.message);
                if (data.status === 'success') {
                    document.getElementById('musicLinkInput').value = '';
                }
            } catch (error) {
                console.error('Error downloading playlist:', error);
                showMessage('error', 'Failed to initiate playlist download.');
            } finally {
                setTimeout(() => _resetDownloadBtn(downloadLinkBtn), 500);
            }
        }

        // Simple playlist download (non-experimental mode)
        async function _downloadPlaylistSimple(url, downloadLinkBtn) {
            try {
                // Get playlist info via preflight
                const preflightResp = await fetch('/api/playlist_preflight', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url })
                });
                const preflight = await preflightResp.json();

                if (preflight.status !== 'success') {
                    showMessage('error', preflight.message || 'Failed to load playlist info');
                    _resetDownloadBtn(downloadLinkBtn);
                    return;
                }

                const playlistName = preflight.name;
                const exists = preflight.exists;

                // If playlist exists, ask for confirmation with custom dialog
                if (exists) {
                    showConfirmDialog(
                        'Playlist Exists',
                        `A playlist named "${playlistName}" already exists in Navidrome. Do you want to overwrite it?`,
                        () => _doPlaylistDownload(url, playlistName, downloadLinkBtn),  // On confirm
                        () => _resetDownloadBtn(downloadLinkBtn)  // On cancel
                    );
                    return;
                }

                // No conflict - download directly
                await _doPlaylistDownload(url, playlistName, downloadLinkBtn);
            } catch (error) {
                console.error('Error downloading playlist:', error);
                showMessage('error', 'Failed to initiate playlist download.');
                _resetDownloadBtn(downloadLinkBtn);
            }
        }

        async function downloadFromLink() {
            const musicLink = document.getElementById('musicLinkInput').value.trim();
            const downloadLinkBtn = document.getElementById('downloadLinkBtn');

            if (!musicLink) {
                showMessage('error', 'Please paste a music link to download.');
                return;
            }

            const isPlaylist = _isPlaylistUrl(musicLink);

            if (isPlaylist) {
                _pendingPlaylistLink = musicLink;
                downloadLinkBtn.innerHTML = '<div class="spinner"></div>Processing...';
                downloadLinkBtn.disabled = true;

                if (experimentalFeaturesEnabled) {
                    // Experimental: Show full popup with monitoring/rename options
                    _showPlaylistPopup(musicLink);
                } else {
                    // Default: Simple download with overwrite confirmation
                    await _downloadPlaylistSimple(musicLink, downloadLinkBtn);
                }
                return;
            }

            // Non-playlist: download immediately
            const originalContent = downloadLinkBtn.innerHTML;
            downloadLinkBtn.innerHTML = '<div class="spinner"></div>Downloading...';
            downloadLinkBtn.disabled = true;

            showMessage('info', 'Download started...');
            downloadQueue.unshift({ artist: 'Link Download', title: musicLink, status: 'in_progress' });
            updateDownloadQueueUI();

            try {
                const response = await fetch('/api/download_from_link', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ link: musicLink })
                });
                const data = await response.json();
                showMessage(data.status, data.message);
                if (data.status === 'success') {
                    document.getElementById('musicLinkInput').value = '';
                }
            } catch (error) {
                console.error('Error downloading from link:', error);
                showMessage('error', 'Failed to initiate download from link.');
            } finally {
                setTimeout(() => {
                    downloadLinkBtn.innerHTML = originalContent;
                    downloadLinkBtn.disabled = false;
                }, 2000);
            }
        }

        // --- Monitored Playlists Management ---
        async function loadMonitoredPlaylists() {
            const container = document.getElementById('monitoredPlaylistsList');
            if (!container) return;
            try {
                const resp = await fetch('/api/monitored_playlists');
                const data = await resp.json();
                if (data.status !== 'success' || !data.playlists.length) {
                    container.innerHTML = '<p style="color: #666; font-size: 0.9em;">No monitored playlists.</p>';
                    return;
                }
                container.innerHTML = data.playlists.map(p => {
                    const userTimezone = document.getElementById('cronTimezone')?.value || 'UTC';
                    // Append 'Z' to indicate the timestamp is UTC (server stores in UTC without timezone marker)
                    const lastSync = p.last_synced ? new Date(p.last_synced + 'Z').toLocaleString(undefined, { timeZone: userTimezone }) : 'Never';
                    const platform = (p.platform || '').charAt(0).toUpperCase() + (p.platform || '').slice(1);
                    const autoCleanupChecked = p.auto_cleanup ? 'checked' : '';
                    return `
                        <div class="mp-item" data-id="${p.id}">
                            <div class="mp-item-info">
                                <div class="mp-item-name" title="${_escHtml(p.url)}">${_escHtml(p.name)}</div>
                                <div class="mp-item-meta">${platform} &middot; ${p.last_track_count || '?'} tracks &middot; Last sync: ${lastSync}</div>
                            </div>
                            <div class="mp-item-actions">
                                <label title="Auto-cleanup old tracks on sync" style="font-size: 0.75em; display: flex; align-items: center; gap: 3px; cursor: pointer;">
                                    <input type="checkbox" ${autoCleanupChecked} onchange="updateMonitoredAutoCleanup('${p.id}', this.checked)">
                                    Cleanup
                                </label>
                                <select onchange="updateMonitoredInterval('${p.id}', this.value)" title="Poll interval">
                                    ${[6,12,24,48,168].map(h =>
                                        `<option value="${h}" ${p.poll_interval_hours === h ? 'selected' : ''}>${h < 48 ? h + 'h' : h === 48 ? '2d' : '7d'}</option>`
                                    ).join('')}
                                </select>
                                <button class="mp-btn-sync" onclick="syncMonitoredPlaylist('${p.id}')" title="Sync now">Sync</button>
                                <button class="mp-btn-remove" onclick="removeMonitoredPlaylist('${p.id}')" title="Stop monitoring">&#x2715;</button>
                            </div>
                        </div>
                    `;
                }).join('');
            } catch (e) {
                container.innerHTML = '<p style="color: var(--error-color); font-size: 0.9em;">Failed to load.</p>';
            }
        }

        async function updateMonitoredInterval(id, hours) {
            await fetch(`/api/monitored_playlists/${id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ poll_interval_hours: parseInt(hours) })
            });
        }

        async function updateMonitoredAutoCleanup(id, enabled) {
            await fetch(`/api/monitored_playlists/${id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ auto_cleanup: enabled })
            });
        }

        async function syncMonitoredPlaylist(id) {
            const resp = await fetch(`/api/monitored_playlists/${id}/sync`, { method: 'POST' });
            const data = await resp.json();
            showMessage(data.status, data.message);
            openDownloadQueueModal();
            // Periodically refresh the monitored list to show updated track count / last sync
            const refreshInterval = setInterval(() => loadMonitoredPlaylists(), 10000);
            setTimeout(() => clearInterval(refreshInterval), 120000);
        }

        async function removeMonitoredPlaylist(id) {
            await fetch(`/api/monitored_playlists/${id}`, { method: 'DELETE' });
            loadMonitoredPlaylists();
        }

        // --- User Settings API ---
        async function saveUserSettings() {
            const settings = {
                listenbrainz_enabled: document.getElementById('listenbrainzEnabled').checked,
                listenbrainz_username: document.getElementById('listenbrainzUser').value.trim(),
                listenbrainz_token: document.getElementById('listenbrainzToken').value.trim(),
                lastfm_enabled: document.getElementById('lastfmEnabled').checked,
                lastfm_username: document.getElementById('lastfmUsername').value.trim(),
            };
            try {
                const response = await fetch('/api/user/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                });
                const data = await response.json();
                showMessage(data.status, data.message);
                if (data.status === 'success') {
                    setTimeout(() => location.reload(), 1000);
                }
            } catch (error) {
                showMessage('error', 'Failed to save settings');
            }
        }

        async function saveProfileSettings() {
            const displayName = document.getElementById('displayName').value.trim();
            try {
                const response = await fetch('/api/user/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ display_name: displayName })
                });
                const data = await response.json();
                showMessage(data.status, data.message);
                if (data.status === 'success') {
                    userDisplayName = displayName || "{{ username }}";
                    showRandomGreeting();
                }
            } catch (error) {
                showMessage('error', 'Failed to save profile');
            }
        }

        async function fetchListenBrainzNow() {
            try {
                const response = await fetch('/api/recommendations/listenbrainz', { method: 'POST' });
                const data = await response.json();
                showMessage(data.status, data.message);
                if (data.status === 'success') {
                    openDownloadQueueModal();
                }
            } catch (error) {
                showMessage('error', 'Failed to start ListenBrainz fetch');
            }
        }

        async function fetchLastFmNow() {
            try {
                const response = await fetch('/api/recommendations/lastfm', { method: 'POST' });
                const data = await response.json();
                showMessage(data.status, data.message);
                if (data.status === 'success') {
                    openDownloadQueueModal();
                }
            } catch (error) {
                showMessage('error', 'Failed to start Last.fm fetch');
            }
        }

        async function loadUserSettings() {
            try {
                const response = await fetch('/api/user/settings');
                const data = await response.json();
                if (data.status === 'success') {
                    const s = data.settings;
                    document.getElementById('listenbrainzEnabled').checked = s.listenbrainz_enabled || false;
                    document.getElementById('listenbrainzUser').value = s.listenbrainz_username || '';
                    document.getElementById('listenbrainzToken').value = s.listenbrainz_token || '';
                    document.getElementById('lastfmEnabled').checked = s.lastfm_enabled || false;
                    document.getElementById('lastfmUsername').value = s.lastfm_username || '';
                    document.getElementById('displayName').value = s.display_name || '';
                    // Load experimental features setting
                    experimentalFeaturesEnabled = s.experimental_features_enabled || false;
                    document.getElementById('experimentalFeaturesEnabled').checked = experimentalFeaturesEnabled;
                    document.getElementById('monitoredPlaylistsSection').style.display = experimentalFeaturesEnabled ? 'block' : 'none';
                    updateListenBrainzVisibility();
                    updateLastFmVisibility();
                }
            } catch (error) {
                console.error('Error loading user settings:', error);
            }
        }

        // PWA Service Worker
        if ('serviceWorker' in navigator) navigator.serviceWorker.register('/sw.js');

        // Auto-load content based on configuration
        window.onload = async function() {
            // Load configuration first to determine what to show
            try {
                const response = await fetch('/api/config');
                const config = await response.json();

                // Cache the configuration for faster settings modal loading
                window.cachedConfig = config;

                // Update UI visibility
                updateUIVisibility(config);

                // Fresh releases hidden by default
                {% if hide_fresh_releases %}
                document.getElementById('freshReleasesSection').style.display = 'none';
                {% else %}
                if (config.LISTENBRAINZ_ENABLED && !config.HIDE_FRESH_RELEASES) {
                    setTimeout(fetchFreshReleases, 100);
                }
                {% endif %}
            } catch (error) {
                console.error('Error loading initial configuration:', error);
            }

            // PWA share target: auto-submit shared URL
            {% if pending_share_url %}
            const sharedUrl = {{ pending_share_url | tojson }};
            if (sharedUrl) {
                const linkInput = document.getElementById('musicLinkInput');
                if (linkInput) {
                    linkInput.value = sharedUrl;
                    // Scroll the download section into view
                    linkInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    // Small delay to let UI settle, then trigger download
                    setTimeout(() => downloadFromLink(), 500);
                }
            }
            {% endif %}
        };
    </script>
</body>
</html>
